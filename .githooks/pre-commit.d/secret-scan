dotfiles/.githooks/pre-commit.d/secret-scan#L1-210
#!/usr/bin/env bash
# pre-commit secret scan hook
#
# Compliant with [/Users/s-a-c/dotfiles/dot-config/ai/guidelines.md](/Users/s-a-c/dotfiles/dot-config/ai/guidelines.md) v50b6b88e7dea25311b5e28879c90b857ba9f1c4b0bc974a72f6b14bc68d54f49
# Policy references:
#   - Security standards (clarity & verifiability) lines 1-8
#   - Logging guidance lines 205-212
#   - Incident response & remediation lines 233-242
#
# PURPOSE
#   Fast local detection of likely secrets before they leave the workstation.
#   Runs Gitleaks if available; otherwise falls back to lightweight pattern + entropy heuristics
#   over the STAGED (cached) diff only.
#
# USAGE
#   Place under .githooks/pre-commit.d/ and configure:
#       git config core.hooksPath .githooks
#
#   To bypass (discouraged except emergencies):
#       SKIP_SECRET_SCAN=1 git commit ...
#
# EXIT CODES
#   0 = no issues
#   1 = potential secret(s) detected
#   2 = internal error (treat like failure)
#
# CONFIGURATION (env vars)
#   SECRET_SCAN_VERBOSE=1     : print debug details
#   SECRET_SCAN_MAX_FINDINGS= : abort early after N findings (default 10)
#   SECRET_SCAN_ALLOW_REGEXES=: comma-separated regex patterns to suppress (applied after detection)
#   SECRET_SCAN_DISABLE_GITLEAKS=1 : force fallback scanner even if gitleaks is installed
#
# PERFORMANCE
#   Uses zero-context (-U0) diff of staged changes only. Large binary files are skipped automatically.
#
# NOTES
#   Entropy heuristic: flags base64/url-safe looking tokens length >= 24 with Shannon entropy >= 3.6.
#   Tune thresholds below if you see noise.

set -euo pipefail

if [[ "${SKIP_SECRET_SCAN:-}" == "1" ]]; then
  echo "[secret-scan] SKIP_SECRET_SCAN=1 -> skipping scan."
  exit 0
fi

VERBOSE=${SECRET_SCAN_VERBOSE:-0}
MAX_FINDINGS=${SECRET_SCAN_MAX_FINDINGS:-10}
ALLOW_RAW=${SECRET_SCAN_ALLOW_REGEXES:-}
DISABLE_GITLEAKS=${SECRET_SCAN_DISABLE_GITLEAKS:-0}

log() {
  [[ "$VERBOSE" == "1" ]] && echo "[secret-scan] $*"
}

warn() {
  echo "[secret-scan][WARN] $*" >&2
}

err() {
  echo "[secret-scan][ERROR] $*" >&2
}

# Collect staged diff (text only)
# Use --cached to focus on what will be committed; exclude deletions for scanning new additions (grep on '^+')
DIFF_RAW=$(git diff --cached --binary --no-color -U0 || true)

if [[ -z "$DIFF_RAW" ]]; then
  log "Empty staged diff; nothing to scan."
  exit 0
fi

# Separate out only added lines (ignore diff metadata and removed lines)
# We keep a little context (the line itself only)
ADDED_LINES=$(printf "%s\n" "$DIFF_RAW" | grep -E '^(\+\+\+ |--- |@@ )|^\+' || true)

# Remove diff headers except added content lines beginning with '+'
# Keep file path context lines for reporting
CLEAN_LINES=$(printf "%s\n" "$ADDED_LINES" | sed '/^+++/d;/^---/d;/^@@/d')

# Early exit if nothing after filtering
if [[ -z "$CLEAN_LINES" ]]; then
  log "No added content lines."
  exit 0
fi

has_command() { command -v "$1" >/dev/null 2>&1; }

GITLEAKS_BIN=""
if [[ "$DISABLE_GITLEAKS" != "1" ]]; then
  if has_command gitleaks; then
    GITLEAKS_BIN="gitleaks"
  elif has_command docker; then
    # Use docker image if local binary absent
    if docker image inspect zricethezav/gitleaks:latest >/dev/null 2>&1; then
      GITLEAKS_BIN="docker run --rm -v $(pwd):/repo -w /repo zricethezav/gitleaks:latest"
    fi
  fi
fi

findings=()

############################
# Gitleaks primary scanner #
############################
run_gitleaks() {
  # Create a temp file containing only the staged tree to avoid scanning the working directory state.
  # Approach: Use 'git checkout-index' to a temp staging dir or archive at HEAD. Simpler: let gitleaks scan repo root but restrict to diff?
  # For speed, feed diff patch directly via detect --no-git which is not supported; fallback: run full repo with respect to ignore rules.
  # We narrow reporting by post-filtering findings to only paths in staged diff.
  local tmp_report
  tmp_report=$(mktemp)
  local config_arg=()
  if [[ -f ".github/gitleaks.toml" ]]; then
    config_arg+=(--config .github/gitleaks.toml)
  fi
  if ! $GITLEAKS_BIN detect "${config_arg[@]}" --no-banner --redact --report-format json --report-path "$tmp_report" >/dev/null 2>&1; then
    log "Gitleaks returned non-zero (may indicate findings or error)."
  fi
  if [[ -s "$tmp_report" ]]; then
    # Extract paths from diff to limit
    local staged_paths
    staged_paths=$(printf "%s\n" "$DIFF_RAW" | grep '^+++ b/' | sed 's|+++ b/||')
    while IFS= read -r path; do
      [[ -z "$path" ]] && continue
      # Grep the JSON report for the path; naive but simple (jq may not exist)
      if grep -F "\"File\":\"$path\"" "$tmp_report" >/dev/null 2>&1; then
        # Extract summary lines (fallback string)
        local lines
        lines=$(grep -F "\"File\":\"$path\"" "$tmp_report" | head -5)
        while IFS= read -r l; do
          [[ -z "$l" ]] && continue
          findings+=("gitleaks:$path:$l")
        done <<< "$lines"
      fi
    done <<< "$staged_paths"
  fi
  rm -f "$tmp_report"
}

####################################
# Fallback pattern & entropy scan  #
####################################
# Patterns (POSIX extended) chosen for low false positive rate
PATTERNS=(
  '-----BEGIN [A-Z ]*PRIVATE KEY-----'
  'AKIA[0-9A-Z]{16}'
  'ASIA[0-9A-Z]{16}'
  'sk-[A-Za-z0-9]{20,}'
  'ghp_[A-Za-z0-9]{36,}'
  'github_pat_[A-Za-z0-9_]{20,}'
  '[A-Za-z0-9+/=]{32,}'          # generic base64-ish (filtered by entropy)
  'eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9._-]+\.[A-Za-z0-9._-]+'  # JWT
  '[A-Za-z0-9_]*SECRET[A-Za-z0-9_]*=["'\'']?[A-Za-z0-9/_\-+=]{12,}["'\'']?'
  '[A-Za-z0-9_]*PASSWORD[A-Za-z0-9_]*=["'\''][^"'\''\r\n]{6,}["'\'']?'
  '[A-Za-z0-9_]*TOKEN[A-Za-z0-9_]*=["'\'']?[A-Za-z0-9/_\-+=]{12,}["'\'']?'
)

# Optional allowlist regexes
IFS=',' read -r -a ALLOW_ARRAY <<< "$ALLOW_RAW"

is_allowed() {
  local candidate="$1"
  for rgx in "${ALLOW_ARRAY[@]}"; do
    [[ -z "$rgx" ]] && continue
    if [[ "$candidate" =~ $rgx ]]; then
      return 0
    fi
  done
  # Generic placeholder filters
  if [[ "$candidate" =~ (REDACTED|PLACEHOLDER|DUMMY|EXAMPLE|SAMPLE) ]]; then
    return 0
  fi
  return 1
}

shannon_entropy() {
  # Arg: string
  local s="$1"
  # Count frequency of each byte
  # Using awk for portability (avoid python dependency)
  printf "%s" "$s" | awk '
    { split($0, a, ""); for(i in a){freq[a[i]]++} }
    END {
      n=length($0); if(n==0){print 0; exit}
      H=0;
      for(c in freq){
        p=freq[c]/n;
        H+= -p*log(p)/log(2);
      }
      printf "%.4f\n", H;
    }'
}

fallback_scan() {
  local line
  local count=0
  while IFS= read -r line; do
    # Only examine added lines
    [[ "$line" != +* ]] && continue
    # Strip leading '+'
    local content=${line#+}
    # Skip obvious non-text/binary markers
    if [[ "$content" =~ ^[[:space:]]*$ ]]; then
      continue
    fi
    for pat in "${PATTERNS[@]}"; do
      if [[ "$content" =~ $pat ]]; then
        local match="${BASH_REMATCH[0]}"
        # Entropy filter for broad base64 pattern (heuristic)
        if [[ "$pat" == '[A-Za-z0-9+/=]{32,}' ]]; then
          local ent
            ent=$(shannon_entropy "$match")
          # Entropy threshold; adjust if noisy
          awk "BEGIN{exit !($ent >= 3.6)}" || continue
        fi
        if is_allowed "$match"; then
          log "Allowed pattern (suppressed): $match"
          continue
        fi
        findings+=("fallback:${match:0:80}")
        count=$((count+1))
        if (( count >= MAX_FINDINGS )); then
          warn "Maximum findings threshold ($MAX_FINDINGS) reached; stopping scan early."
          return
        fi
      fi
    done
  done <<< "$CLEAN_LINES"
}

############################################
# Run scanners
############################################
if [[ -n "$GITLEAKS_BIN" ]]; then
  log "Running gitleaks scanner..."
  run_gitleaks
else
  log "Gitleaks unavailable or disabled; using fallback scanner."
  fallback_scan
fi

############################################
# Report
############################################
if ((${#findings[@]}==0)); then
  log "No potential secrets detected."
  exit 0
fi

echo
echo "============================================"
echo " Potential secret indicators detected"
echo "============================================"
for f in "${findings[@]}"; do
  echo " - $f"
done
echo
echo "Action required: Review and remove/redact secrets BEFORE committing."
echo "To bypass (not recommended): SKIP_SECRET_SCAN=1 git commit ..."
echo

exit 1
