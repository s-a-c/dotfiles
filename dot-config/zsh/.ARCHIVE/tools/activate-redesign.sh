#!/usr/bin/env zsh
#
# tools/activate-redesign.sh
#
# Activation helper for the ZSH redesign (feature-flagged, opt-in).
# Provides safe enable/disable/backup/restore helpers that make it easy
# to run the redesigned configuration from this feature branch locally.
#
# Usage:
#   ./activate-redesign.sh --enable      # Interactive prompt, will backup and inject enable wrapper
#   ./activate-redesign.sh --disable     # Restore previous state from backup
#   ./activate-redesign.sh --backup      # Create a manual backup of user zshenv/zshrc related files
#   ./activate-redesign.sh --restore     # Restore the most recent backup
#   ./activate-redesign.sh --status      # Show current activation/status info
#   ./activate-redesign.sh --dry-run     # Show what would be done (combine with other flags)
#
# Notes:
# - The script is opt-in and will not enable redesign without explicit confirmation unless --yes is passed.
# - The script attempts to be conservative: it backs up user files before changing them.
# - This script alters your local dotfiles (typically ~/.zshenv). If you prefer not to modify, use the `ZSH_USE_REDESIGN=1` env export
#   when launching a one-off shell: `env ZSH_USE_REDESIGN=1 ZDOTDIR=$PWD/dot-config/zsh zsh -i -f`
#
# Author: s-a-c (implemented/maintained)
# Created: 2025-09-07
set -euo pipefail

# ---------- Configuration ----------
SCRIPT_PATH="$(cd "$(dirname "${0:A}")" && pwd -P)"
# Repo root is three levels up from tools -> zsh -> dot-config -> dotfiles
REPO_ROOT="$(cd "${SCRIPT_PATH}/../../.." && pwd -P)"
REDESIGN_ZDOTDIR="${REPO_ROOT}/dot-config/zsh"
RENAME_PREFIX="redesign"
BACKUP_DIR="${HOME}/.${RENAME_PREFIX}-backups"
REDESIGN_ENV_FILE="${REPO_ROOT}/dot-config/zsh/tools/redesign-env.sh"
ZSHENV_PATH="${HOME}/.zshenv"
ZSHRC_PATH="${HOME}/.zshrc"
DRY_RUN=0
AUTO_YES=0

timestamp() { date +"%Y%m%dT%H%M%S"; }
log() { printf '[activate-redesign] %s\n' "$*"; }
err() { printf '[activate-redesign] ERROR: %s\n' "$*" >&2; }

usage() {
  cat <<EOF
Usage: $0 [OPTIONS] COMMAND

Commands:
  --enable        Enable the redesign for local shells (injects an opt-in wrapper into ${ZSHENV_PATH}).
  --disable       Disable the redesign (restore previous ${ZSHENV_PATH} backup).
  --backup        Create a manual backup of user's zsh config files (~/.zshenv, ~/.zshrc).
  --restore       Restore the latest backup created by this script.
  --status        Show current status (is redesign enabled? backups available?).
  --dry-run       Do not make changes; print planned actions.
  --yes           Auto-confirm prompts.

Examples:
  $0 --enable
  $0 --enable --yes
  $0 --disable
  $0 --status

Notes:
- This script is opt-in. It will not enable redesign without confirmation unless --yes is passed.
- For one-off testing without modifying files, you can run:
    env ZSH_USE_REDESIGN=1 ZDOTDIR=${REDESIGN_ZDOTDIR} zsh -i -f
EOF
  exit 1
}

# ---------- Helpers ----------
ensure_backup_dir() {
  if (( DRY_RUN )); then
    log "DRY-RUN: Would ensure backup dir ${BACKUP_DIR}"
    return
  fi
  if [[ ! -d "${BACKUP_DIR}" ]]; then
    mkdir -p -- "${BACKUP_DIR}"
    log "Created backup directory: ${BACKUP_DIR}"
  fi
}

safe_copy() {
  local src="$1" dst="$2"
  if [[ ! -e "$src" ]]; then
    log "Skipping copy; source does not exist: $src"
    return 0
  fi
  if (( DRY_RUN )); then
    log "DRY-RUN: Would copy ${src} -> ${dst}"
    return 0
  fi
  cp -a -- "${src}" "${dst}"
}

backup_file() {
  local f="$1"
  if [[ ! -e "${f}" ]]; then
    log "No file to backup: ${f}"
    return 0
  fi
  ensure_backup_dir
  local stamp
  stamp="$(timestamp)"
  local bn
  bn="$(basename "${f}")"
  local target="${BACKUP_DIR}/${bn}.${stamp}.bak"
  if (( DRY_RUN )); then
    log "DRY-RUN: Would backup ${f} -> ${target}"
    return 0
  fi
  cp -a -- "${f}" "${target}"
  log "Backed up ${f} -> ${target}"
}

restore_latest_backup_for() {
  local file="$1"
  local bn
  bn="$(basename "${file}")"
  local latest
  latest="$(ls -1t "${BACKUP_DIR}/${bn}."*".bak" 2>/dev/null | head -n1 || true)"
  if [[ -z "${latest}" ]]; then
    err "No backup found for ${file} in ${BACKUP_DIR}"
    return 1
  fi
  if (( DRY_RUN )); then
    log "DRY-RUN: Would restore ${latest} -> ${file}"
    return 0
  fi
  cp -a -- "${latest}" "${file}"
  log "Restored ${latest} -> ${file}"
}

create_redesign_env_file() {
  if (( DRY_RUN )); then
    log "DRY-RUN: Would create redesign env file at ${REDESIGN_ENV_FILE}"
    return 0
  fi
  mkdir -p -- "$(dirname "${REDESIGN_ENV_FILE}")"
  cat >| "${REDESIGN_ENV_FILE}" <<EOF
# Auto-generated by tools/activate-redesign.sh
# This file exports environment settings for using the redesign from the repo.
# Source this file in your shell (it is referenced by the injected ~/.zshenv snippet).
export ZSH_USE_REDESIGN=1
export ZDOTDIR="${REDESIGN_ZDOTDIR}"
# Add any redesign-specific overrides here
# Example: export ZSH_CACHE_DIR="\$ZDOTDIR/.cache"
EOF
  chmod 644 "${REDESIGN_ENV_FILE}" || true
  log "Wrote redesign env helper: ${REDESIGN_ENV_FILE}"
}

inject_zshenv_snippet() {
  local snippet_marker="# >>> REDESIGN-ENV (managed by activate-redesign.sh) >>>"
  local snippet_end="# <<< REDESIGN-ENV (managed by activate-redesign.sh) <<<"
  local inject_content
  inject_content="${snippet_marker}
# The following is added to enable the redesign (opt-in).
# It sources the repo-local redesign environment file when ZSH_USE_REDESIGN is set.
if [[ -f \"${REDESIGN_ENV_FILE}\" ]]; then
  source \"${REDESIGN_ENV_FILE}\"
fi
${snippet_end}
"

  if [[ -f "${ZSHENV_PATH}" ]]; then
    # If ZSHENV already contains our injection, replace it; otherwise append backup then append snippet
    if grep -q "${snippet_marker}" "${ZSHENV_PATH}" >/dev/null 2>&1; then
      if (( DRY_RUN )); then
        log "DRY-RUN: Would update existing redesign snippet in ${ZSHENV_PATH}"
      else
        # Replace existing block (simple sed-based approach)
        awk -v start="${snippet_marker}" -v end="${snippet_end}" -v new="${inject_content}" '
          BEGIN{inblock=0}
          $0==start{print new; inblock=1; next}
          $0==end{inblock=0; next}
          { if(!inblock) print $0 }
        ' "${ZSHENV_PATH}" > "${ZSHENV_PATH}.tmp" && mv "${ZSHENV_PATH}.tmp" "${ZSHENV_PATH}"
        log "Updated redesign snippet in ${ZSHENV_PATH}"
      fi
    else
      # Append snippet
      if (( DRY_RUN )); then
        log "DRY-RUN: Would append redesign snippet to ${ZSHENV_PATH}"
      else
        printf "\n%s\n" "${inject_content}" >>| "${ZSHENV_PATH}"
        log "Appended redesign snippet to ${ZSHENV_PATH}"
      fi
    fi
  else
    # no zshenv exists; create one with snippet (also back up nothing)
    if (( DRY_RUN )); then
      log "DRY-RUN: Would create ${ZSHENV_PATH} with redesign snippet"
    else
      printf "%s\n" "${inject_content}" >| "${ZSHENV_PATH}"
      chmod 644 "${ZSHENV_PATH}" || true
      log "Created ${ZSHENV_PATH} with redesign snippet"
    fi
  fi
}

remove_redesign_snippet() {
  local snippet_marker="# >>> REDESIGN-ENV (managed by activate-redesign.sh) >>>"
  if [[ ! -f "${ZSHENV_PATH}" ]]; then
    log "No ${ZSHENV_PATH} to update"
    return 0
  fi
  if ! grep -q "${snippet_marker}" "${ZSHENV_PATH}" >/dev/null 2>&1; then
    log "No redesign snippet present in ${ZSHENV_PATH}"
    return 0
  fi
  if (( DRY_RUN )); then
    log "DRY-RUN: Would remove redesign snippet from ${ZSHENV_PATH}"
    return 0
  fi
  awk -v start="${snippet_marker}" '
    BEGIN{inblock=0}
    $0==start{inblock=1; next}
    inblock && $0 ~ /REDESIGN-ENV \(managed by activate-redesign.sh\) <<</ { inblock=0; next }
    { if(!inblock) print $0 }' "${ZSHENV_PATH}" > "${ZSHENV_PATH}.tmp" && mv "${ZSHENV_PATH}.tmp" "${ZSHENV_PATH}"
  log "Removed redesign snippet from ${ZSHENV_PATH}"
}

show_status() {
  echo "Activation Status:"
  if grep -q "ZSH_USE_REDESIGN" "${ZSHENV_PATH}" >/dev/null 2>&1; then
    echo "  - ${ZSHENV_PATH}: contains redesign snippet"
  else
    echo "  - ${ZSHENV_PATH}: no redesign snippet found"
  fi
  if [[ -f "${REDESIGN_ENV_FILE}" ]]; then
    echo "  - redesign env helper exists: ${REDESIGN_ENV_FILE}"
    echo "      ZDOTDIR -> ${REDESIGN_ZDOTDIR}"
  else
    echo "  - redesign env helper missing: ${REDESIGN_ENV_FILE}"
  fi
  if [[ -d "${BACKUP_DIR}" ]]; then
    echo "  - Backups directory: ${BACKUP_DIR}"
    echo "    Recent backups:"
    ls -1t "${BACKUP_DIR}" 2>/dev/null | head -n10 || echo "      (none)"
  else
    echo "  - No backups directory found (${BACKUP_DIR})"
  fi
  echo
  echo "Quick test (one-off shell without modifying files):"
  echo "  env ZSH_USE_REDESIGN=1 ZDOTDIR='${REDESIGN_ZDOTDIR}' zsh -i -f"
}

confirm() {
  local prompt="$1"
  if (( AUTO_YES )); then
    return 0
  fi
  printf "%s [y/N]: " "${prompt}"
  read -r ans
  case "${ans}" in
    y|Y|yes|YES) return 0 ;;
    *) return 1 ;;
  esac
}

# ---------- Actions ----------
do_enable() {
  log "Enable: starting redesign activation (opt-in)."
  if (( DRY_RUN )); then
    log "DRY-RUN MODE: No files will be changed."
  fi

  if [[ -f "${ZSHENV_PATH}" ]]; then
    log "Backing up current ${ZSHENV_PATH}..."
    backup_file "${ZSHENV_PATH}"
  else
    log "No existing ${ZSHENV_PATH} found; will create one."
  fi

  create_redesign_env_file

  if (( DRY_RUN )); then
    log "DRY-RUN: Would inject snippet into ${ZSHENV_PATH} to source ${REDESIGN_ENV_FILE}."
  else
    if ! (( AUTO_YES )); then
      confirm "Proceed to inject redesign snippet into ${ZSHENV_PATH}? This will modify your file and a backup was created." || {
        log "Operation cancelled by user."
        return 1
      }
    fi
    inject_zshenv_snippet
    log "Activation complete. Start a new shell or run: env ZSH_USE_REDESIGN=1 ZDOTDIR='${REDESIGN_ZDOTDIR}' zsh -i -f"
  fi
}

do_disable() {
  log "Disable: attempting to remove redesign activation."
  if (( DRY_RUN )); then
    log "DRY-RUN: Would remove redesign snippet and not restore backups."
    return 0
  fi

  if ! (( AUTO_YES )); then
    confirm "Proceed to remove redesign snippet from ${ZSHENV_PATH} and (optionally) restore backups?" || {
      log "Operation cancelled by user."
      return 1
    }
  fi

  remove_redesign_snippet

  # Attempt to restore latest backup if user wants it
  if [[ -d "${BACKUP_DIR}" ]]; then
    if confirm "Restore the most recent backup of ${ZSHENV_PATH} from ${BACKUP_DIR}?"; then
      restore_latest_backup_for "${ZSHENV_PATH}" || log "Restore failed or no backup available."
    else
      log "Skipped restore of ${ZSHENV_PATH}."
    fi
  else
    log "No backup directory found; skipping restore."
  fi

  log "Disable complete. You may need to restart shells to pick up change."
}

do_backup() {
  log "Manual backup of primary files."
  ensure_backup_dir
  backup_file "${ZSHENV_PATH}"
  backup_file "${ZSHRC_PATH}"
  log "Manual backup complete."
}

do_restore() {
  log "Restore latest backups for primary files."
  if [[ ! -d "${BACKUP_DIR}" ]]; then
    err "No backups found in ${BACKUP_DIR}"
    return 1
  fi
  restore_latest_backup_for "${ZSHENV_PATH}" || true
  restore_latest_backup_for "${ZSHRC_PATH}" || true
  log "Restore complete (where backups existed)."
}

# ---------- CLI parse ----------
if (( $# == 0 )); then
  usage
fi

ACTION=""
while (( $# )); do
  case "$1" in
    --enable) ACTION="enable"; shift ;;
    --disable) ACTION="disable"; shift ;;
    --backup) ACTION="backup"; shift ;;
    --restore) ACTION="restore"; shift ;;
    --status) ACTION="status"; shift ;;
    --dry-run) DRY_RUN=1; shift ;;
    --yes) AUTO_YES=1; shift ;;
    -h|--help) usage ;;
    *) err "Unknown arg: $1"; usage ;;
  esac
done

case "${ACTION}" in
  enable)
    do_enable
    ;;
  disable)
    do_disable
    ;;
  backup)
    do_backup
    ;;
  restore)
    do_restore
    ;;
  status)
    show_status
    ;;
  *)
    err "No action specified."
    usage
    ;;
esac

exit 0
