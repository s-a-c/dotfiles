if ! (( ${+STARSHIP_PIPE_STATUS} )); then typeset -ga STARSHIP_PIPE_STATUS; STARSHIP_PIPE_STATUS=(); fi

# Minimal defaults to avoid set -u trips for external configs
: ${INTELLIJ_ENVIRONMENT_READER:=}
: ${LSCOLORS:=}
: ${LS_COLORS:=}
: ${SSH_CLIENT:=}


# Additional safe defaults for variables referenced by upstream ZQS/.zshrc and common plugins
: ${SSH_AUTH_SOCK:=}
: ${GENCOMPL_PY:=}
: ${ZSH_COMPLETION_HACK:=}
: ${TREE_IGNORE:=}
: ${DESK_ENV:=}
: ${GOPATH:=}
: ${QUICKSTART_KIT_REFRESH_IN_DAYS:=}
: ${ZGENOM_AUTO_ADD_BIN:=1}
: ${BREW_PREFIX:=}
: ${ONE_P_SOCK:=}
: ${SHOWED_SCREEN_MESSAGE:=}
: ${ZPFX:=${HOME}/.local}
: ${ZGENOM_SOURCE_BIN:=0}
: ${FAST_BASE_DIR:=}
# zgenom option arrays and related vars: seed as empty to avoid nounset trips during save/init
typeset -ga ZGENOM_LOADED 2>/dev/null || true
: ${ZGEN_USE_PREZTO:=0}

: ${ZGENOM_LOADED:=()}
typeset -ga ZGEN_LOADED 2>/dev/null || true
: ${ZGEN_LOADED:=()}
typeset -ga ZGENOM_PLUGINS 2>/dev/null || true
: ${ZGENOM_PLUGINS:=()}
typeset -ga ZGEN_PREZTO_OPTIONS 2>/dev/null || true
: ${ZGEN_PREZTO_OPTIONS:=()}
typeset -ga ZGEN_PREZTO_LOAD 2>/dev/null || true
: ${ZGEN_PREZTO_LOAD:=()}
typeset -ga ZGEN_COMPLETIONS 2>/dev/null || true
: ${ZGEN_COMPLETIONS:=()}
typeset -ga zsh_loaded_plugins 2>/dev/null || true
: ${zsh_loaded_plugins:=()}
: ${ZGEN_CUSTOM_COMPDUMP:=}
: ${ZGEN_PREZTO_LOAD_DEFAULT:=1}
: ${ZGEN_OH_MY_ZSH_REPO:=ohmyzsh/ohmyzsh}
: ${ZGEN_PREZTO_REPO:=sorin-ionescu}
: ${ZGEN_COMPINIT_DIR_FLAG:=}
: ${ZGEN_COMPINIT_FLAGS:=}


# Positional parameter guard: ensure $1/$2 exist to avoid nounset in upstream alias/scripts
if [[ -z ${1+x} || -z ${2+x} ]]; then
    set -- "${1-}" "${2-}" "${@:3}"
fi




# fzf integration can reference FZF_PATH very early; provide a lightweight default
if [[ -z "${FZF_PATH-}" ]]; then
    if [[ -d "${HOME}/.fzf" ]]; then
        export FZF_PATH="${HOME}/.fzf"
    elif [[ -d "/opt/homebrew/opt/fzf" ]]; then
        export FZF_PATH="/opt/homebrew/opt/fzf"
    elif [[ -d "/usr/local/opt/fzf" ]]; then
        export FZF_PATH="/usr/local/opt/fzf"
    else
        export FZF_PATH=""
    fi
fi

# AWS and cloud service variables
typeset -g AWS_PROFILE_REGION="${AWS_PROFILE_REGION-}"
typeset -g AWS_PROFILE="${AWS_PROFILE-}"
typeset -g AWS_DEFAULT_PROFILE="${AWS_DEFAULT_PROFILE-}"
typeset -g AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID-}"

# Ruby version management variables
typeset -g RUBY_AUTO_VERSION="${RUBY_AUTO_VERSION-}"
typeset -g CHRUBY_VERSION="${CHRUBY_VERSION-}"
typeset -g RUBY_VERSION="${RUBY_VERSION-}"

# ZLE and widget variables (let ZLE initialize these itself)
typeset -g ZLE_LINE_ABORTED="${ZLE_LINE_ABORTED-}"
typeset -g ZLE_STATE="${ZLE_STATE-}"
typeset -g KEYMAP="${KEYMAP-}"

# DO NOT initialize widgets array here - this interferes with ZLE initialization
# ZLE needs to control widgets array creation to properly populate built-in widgets

# DO NOT initialize parameters or functions arrays - these are ZSH internals
# ZSH manages these arrays automatically and pre-initialization can cause issues

# ------------------------------------------------------------------------------
# PATH Management Functions
# ------------------------------------------------------------------------------
# These functions automatically dedupe by removing the target path before
# pre/appending it, as suggested by the user

## [zf::path.remove]
zf::path_remove() {
  for ARG in "$@"; do
    while [[ ":${PATH}:" == *":${ARG}:"* ]]; do
      # Delete by parts to avoid removing subpaths accidentally
      [[ "${PATH}" == "${ARG}" ]] && PATH=""
      PATH=${PATH//":${ARG}:"/:}   # middle
      PATH=${PATH/#"${ARG}:"/}     # beginning
      PATH=${PATH/%":${ARG}"/}     # end
      export PATH
    done
  done
}

## [zf::path.append]
zf::path_append() {
  for ARG in "$@"; do
    zf::path_remove "${ARG}"
    [[ -d "${ARG}" ]] && export PATH="${PATH:+"${PATH}:"}${ARG}"
  done
}

## [zf::path.prepend]
zf::path_prepend() {
  for ARG in "$@"; do
    zf::path_remove "${ARG}"
    [[ -d "${ARG}" ]] && export PATH="${ARG}${PATH:+":${PATH}"}"
  done
}

# Back-compat wrappers
_path_remove()  { zf::path_remove  "$@"; }
_path_append()  { zf::path_append  "$@"; }
_path_prepend() { zf::path_prepend "$@"; }

zf::debug "[DEBUG] early .zshenv:" || true
zf::debug "    ZDOTDIR=${ZDOTDIR}" || true
zf::debug "    ZSH_CACHE_DIR=${ZSH_CACHE_DIR}" || true
zf::debug "    ZSH_LOG_DIR=${ZSH_LOG_DIR}" || true

# ------------------------------------------------------------------------------
# Utility: PATH de-duplication (preserve first occurrence)
# ------------------------------------------------------------------------------
zf::path_dedupe() {
  # Portable PATH de-duplication
  local verbose=0 dry=0 arg p _before=0 _after=0 _x
  for arg in "$@"; do
    case "$arg" in
      --verbose) verbose=1 ;;
      --dry-run) dry=1 ;;
    esac
  done
  local original="$PATH"
  local IFS=:
  local seen_list=""
  for p in $PATH; do
    [ -z "$p" ] && continue
    case ":$seen_list:" in
      *:"$p":*) continue ;;
      *) seen_list="${seen_list:+$seen_list:}$p" ;;
    esac
  done
  local deduped="$seen_list"
  if [ "$dry" -eq 1 ]; then
    printf '%s\n' "${deduped:-$original}"
    return 0
  fi
  if [ "$deduped" != "$original" ]; then
    PATH="$deduped"
    export PATH
  fi
  PATH_DEDUP_DONE=1
  if [ "$verbose" -eq 1 ]; then
    IFS=:; for _x in $original; do _before=$((_before+1)); done
    IFS=:; for _x in $deduped; do _after=$((_after+1)); done
    printf '[path_dedupe] entries(before)=%s entries(after)=%s\n' "$_before" "$_after" >&2
  fi
}

# Back-compat wrapper
path_dedupe() { zf::path_dedupe "$@"; }

# Deduplicate initial PATH (idempotent)
zf::path_dedupe >/dev/null 2>&1 || true

# ------------------------------------------------------------------------------
# Resilient Script Directory Resolution
# ------------------------------------------------------------------------------
# Public helper (core): resolve_script_dir [<path_or_script>]
#   - Resolves symlinks
#   - Uses zsh parameter expansion ${(%):-%N} when no argument given
#   - Returns canonical physical directory (pwd -P) or empty on failure
# Namespaced convenience (preferred in modules): zf::script_dir [<path_or_script>]
# ------------------------------------------------------------------------------
if ! typeset -f zf::resolve_script_dir >/dev/null 2>&1; then
zf::resolve_script_dir() {
  (
    emulate -L zsh
    set -o no_unset
    local src="${1:-${(%):-%N}}"
    [[ -z "$src" ]] && { print -r -- "$PWD"; return 0; }
    local link
    while [[ -h "$src" ]]; do
      link="$(readlink "$src" 2>/dev/null || true)"
      [[ -z "$link" ]] && break
      if [[ "$link" == /* ]]; then
        src="$link"
      else
        src="${src:h}/$link"
      fi
    done
    builtin cd -q "${src:h}" 2>/dev/null || { print -r -- "${src:h}"; return 0; }
    pwd -P
  )
}
fi
# Back-compat wrapper
if ! typeset -f resolve_script_dir >/dev/null 2>&1; then
resolve_script_dir() { zf::resolve_script_dir "${1:-}"; }
fi
if ! typeset -f zf::script_dir >/dev/null 2>&1; then
zf::script_dir() { zf::resolve_script_dir "${1:-}"; }
fi

export ZSH_SCRIPT_DIR_HELPERS=1
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Harness Watchdog
# Reworked: signal the parent interactive shell PID instead of exiting only the
# background subshell. Prevents hangs when perf-capture harness shells stall.
# Behavior:
#   - If PERF_HARNESS_TIMEOUT_SEC > 0, record HARNESS_PARENT_PID=$$ (if unset) and
#     launch a background watcher.
#   - After sleep(timeout) if still a harness context (PERF_PROMPT_HARNESS or
#     PERF_SEGMENT_LOG set) and parent PID alive, send TERM; after a short grace
#     (default 0.4s) send KILL if still running.
# Opt-out: set PERF_HARNESS_DISABLE_WATCHDOG=1
# ------------------------------------------------------------------------------
if [ "${PERF_HARNESS_TIMEOUT_SEC:-0}" -gt 0 ] && [ "${PERF_HARNESS_DISABLE_WATCHDOG:-0}" != "1" ]; then
    # Record parent PID for signaling (do not override if already set by caller)
    : "${HARNESS_PARENT_PID:=$$}"
    export HARNESS_PARENT_PID
    (
        timeout_sec="${PERF_HARNESS_TIMEOUT_SEC}"
        grace_ms="${PERF_HARNESS_GRACE_MS:-400}"
        sleep "${timeout_sec}"
        if [[ -n "${PERF_PROMPT_HARNESS:-}" || -n "${PERF_SEGMENT_LOG:-}" ]]; then
        if kill -0 "${HARNESS_PARENT_PID}" 2>/dev/null; then
            kill -TERM "${HARNESS_PARENT_PID}" 2>/dev/null || true
            # Convert grace to fractional seconds (numeric grace_ms -> ms to s.mmm; fallback 0.4s)
            case "$grace_ms" in
            ''|*[!0-9]*)
                sleep 0.4
                ;;
            *)
                _g="$grace_ms"
                sleep "$(printf '%d.%03d' $((_g/1000)) $((_g%1000)))"
                unset _g
                ;;
            esac
            kill -0 "${HARNESS_PARENT_PID}" 2>/dev/null && kill -KILL "${HARNESS_PARENT_PID}" 2>/dev/null || true
        fi
        fi
    ) &
fi
# ------------------------------------------------------------------------------
# Minimal perf harness mode (PERF_HARNESS_MINIMAL=1)
# Skips heavy plugin/theme initialization; loads only prompt-ready instrumentation
# and lightweight segment markers to allow perf-capture tooling to complete quickly
# in constrained CI sandboxes. Must appear before plugin manager / theme logic.
# ------------------------------------------------------------------------------
if [[ "${PERF_HARNESS_MINIMAL:-0}" == "1" ]]; then
    # Minimal perf harness path detected, but early return disabled to allow full interactive startup.
    # (Original minimal fast path intentionally bypassed.)
    ZSH_DEBUG=${ZSH_DEBUG:-0}
    export ZSH_PERF_PROMPT_MARKERS=1
    if [[ -f "${ZDOTDIR}/.zshrc.d.REDESIGN/95-prompt-ready.zsh" ]]; then
        source "${ZDOTDIR}/.zshrc.d.REDESIGN/95-prompt-ready.zsh"
    fi
    if [[ -f "${ZDOTDIR}/tools/segment-lib.zsh" ]]; then
        source "${ZDOTDIR}/tools/segment-lib.zsh"
    fi
    # return 0  # disabled
fi

# ------------------------------------------------------------------------------
# Helpers: command existence caching and safe wrappers
# ------------------------------------------------------------------------------
declare -gA _zsh_command_cache

# Primary (namespaced)
zf::has_command() {
  local cmd="$1"
  local cache_key="cmd_$cmd"
  [[ -n "$cmd" ]] || return 1
  if [[ -n "${_zsh_command_cache[$cache_key]:-}" ]]; then
    [[ "${_zsh_command_cache[$cache_key]}" == "1" ]] && return 0 || return 1
  fi
  if command -v "$cmd" >/dev/null 2>&1; then
    _zsh_command_cache[$cache_key]="1"
    return 0
  else
    _zsh_command_cache[$cache_key]="0"
    return 1
  fi
}

# Back-compat wrappers
has_command()      { zf::has_command "$@"; }
zf::command_exists(){ zf::has_command "$@"; }
command_exists()   { zf::has_command "$@"; }

# Git wrapper (namespaced)
zf::safe_git() {
  if [[ -x "/opt/homebrew/bin/git" ]]; then
    /opt/homebrew/bin/git "$@"
  elif [[ -x "/usr/local/bin/git" ]]; then
    /usr/local/bin/git "$@"
  else
    command git "$@"
  fi
}
# Back-compat wrappers
safe_git() { zf::safe_git "$@"; }
if ! typeset -f _lazy_gitwrapper >/dev/null 2>&1; then
  _lazy_gitwrapper() { zf::safe_git "$@"; }
fi

# ------------------------------------------------------------------------------
# ZGENOM / plugin manager variables (use ZDOTDIR to localize installs)
# Prefer non-dot `zgenom` locations but keep backwards compatible fallbacks.
# ------------------------------------------------------------------------------
ZGENOM_PARENT_DIR="${ZDOTDIR}"

# Resolve the zgenom source directory in priority order:
# 1) localized vendored .zqs-zgenom under $ZDOTDIR (preferred for localized installs)
# 2) localized zgenom under $ZDOTDIR (stow-friendly, no leading dot)
# 3) localized legacy .zgenom under $ZDOTDIR
# 4) user-home fallback ${HOME}/.zgenom
# If none exist, default to the stow-friendly name under ZDOTDIR so callers
# that write into the stowed config know the expected location.
if [[ -n "${ZDOTDIR:-}" && -d "${ZDOTDIR}/.zqs-zgenom" ]]; then
    ZGEN_SOURCE="${ZDOTDIR}/.zqs-zgenom"
elif [[ -n "${ZDOTDIR:-}" && -d "${ZDOTDIR}/zgenom" ]]; then
    ZGEN_SOURCE="${ZDOTDIR}/zgenom"
elif [[ -n "${ZDOTDIR:-}" && -d "${ZDOTDIR}/.zgenom" ]]; then
    ZGEN_SOURCE="${ZDOTDIR}/.zgenom"
elif [[ -d "${HOME}/.zgenom" ]]; then
    ZGEN_SOURCE="${HOME}/.zgenom"
else
    ZGEN_SOURCE="${ZDOTDIR}/zgenom"
fi

# Primary zgenom entry points derived from chosen source
ZGENOM_SOURCE_FILE=$ZGEN_SOURCE/zgenom.zsh

ZGEN_DIR="${ZGEN_SOURCE}"
ZGEN_INIT="${ZGEN_DIR}/init.zsh"
ZGENOM_BIN_DIR="${ZGEN_DIR}/_bin"

export ZGENOM_PARENT_DIR ZGEN_SOURCE ZGENOM_SOURCE_FILE ZGEN_DIR ZGEN_INIT ZGENOM_BIN_DIR

# Completion behavior control: set to 0 to avoid automatic compinit while debugging.
# When you are confident completions/fpath are correct, you can set this to 1.
export ZGEN_AUTOLOAD_COMPINIT="${ZGEN_AUTOLOAD_COMPINIT:-0}"

# Debug info (only prints when ZSH_DEBUG=1)
zf::debug "[DEBUG]: localized zgenom configuration:" || true
zf::debug "    ZGEN_SOURCE=${ZGEN_SOURCE-}" || true
zf::debug "    ZGENOM_SOURCE_FILE=${ZGENOM_SOURCE_FILE-}" || true
zf::debug "    ZGEN_DIR=${ZGEN_DIR-}" || true
zf::debug "    ZGEN_INIT=${ZGEN_INIT-}" || true
zf::debug "    ZGEN_AUTOLOAD_COMPINIT=${ZGEN_AUTOLOAD_COMPINIT-}" || true

# (Removed duplicate feature flag exports: ZSH_ENABLE_NVM_PLUGINS, ZSH_NODE_LAZY, ZSH_ENABLE_ABBR)

# ------------------------------------------------------------------
# Core PATH fallback (Stage 2 stabilization)
# Ensures essential system utilities (awk, date, mkdir, sed, grep, etc.)
# are available even in constrained early interactive shells invoked
# by performance harnesses or baseline scripts. This appends missing
# core directories without disturbing existing ordering when present.
# Safe: only appends; does not reorder front-of-line priorities.
# ------------------------------------------------------------------
{
    _core_added=0
    for __core_dir in /usr/local/bin /opt/homebrew/bin /usr/bin /bin /usr/sbin /sbin; do
        [ -d "$__core_dir" ] || continue
        case ":$PATH:" in
        *:"$__core_dir":*) ;;
        *)
            PATH="${PATH:+$PATH:}$__core_dir"
            _core_added=$(( _core_added + 1 ))
            ;;
        esac
    done
    export PATH
    unset __core_dir _core_added
}

# Optional: custom compdump location and compinit flags (keeps compdump in cache)
export ZGEN_CUSTOM_COMPDUMP="${ZGEN_CUSTOM_COMPDUMP:-${ZSH_CACHE_DIR}/zcompdump_${ZSH_VERSION:-unknown}}"
export ZGEN_COMPINIT_FLAGS="${ZGEN_COMPINIT_FLAGS:-${ZGEN_COMPINIT_FLAGS:-}}"

# Optional: oh-my-zsh repo/branch defaults used by some starter plugin lists
export ZGEN_OH_MY_ZSH_REPO="${ZGEN_OH_MY_ZSH_REPO:-ohmyzsh/ohmyzsh}"
export ZGEN_OH_MY_ZSH_BRANCH="${ZGEN_OH_MY_ZSH_BRANCH:-master}"

# Initialize fpath if not already set (prevents unbound variable errors)
: ${fpath:=()}

# Add vendored zgenom functions to fpath early if present (try source then dir)
if [[ -d "${ZGEN_SOURCE}/functions" ]]; then
    fpath=("${ZGEN_SOURCE}/functions" $fpath)
elif [[ -d "${ZGEN_DIR}/functions" ]]; then
    fpath=("${ZGEN_DIR}/functions" $fpath)
fi

# ------------------------------------------------------------------------------
# History defaults anchored in localized ZDOTDIR
# ------------------------------------------------------------------------------
export HISTFILE="${ZDOTDIR}/.zsh_history"
export HISTSIZE="${HISTSIZE:-2000000}"
export SAVEHIST="${SAVEHIST:-2000200}"
export HISTTIMEFORMAT="${HISTTIMEFORMAT:-'%F %T %z %a %V '}"
export HISTDUP="${HISTDUP:-erase}"

# ------------------------------------------------------------------------------
# Final early housekeeping
# ------------------------------------------------------------------------------
# Make sure .env files under ZDOTDIR/.env (if any) are loaded for both
# interactive and non-interactive shells. These files are expected to contain
# user-level environment variables and API keys the user wants available.
if [[ -d "${ZDOTDIR}/.env" ]]; then
    for env_file in "${ZDOTDIR}/.env"/*.env; do
        [[ -r "$env_file" ]] && source "$env_file"
    done
    unset env_file
fi

# Export a stable EDITOR/VISUAL if not already set (best-effort)
if [[ -z "${EDITOR:-}" ]]; then
    for e in nvim vim nano; do
        if command -v "$e" >/dev/null 2>&1; then
            export EDITOR="$e"
            break
        fi
    done
fi
if [[ -z "${VISUAL:-}" ]]; then
    for v in "$EDITOR" code code-insiders; do
        command -v "${v}" >/dev/null 2>&1 && { export VISUAL="$v"; break; } || true
    done
fi

# Set a sane default LANG/LC if unset
export LANG="${LANG:-en_GB.UTF-8}"
export LC_ALL="${LC_ALL:-${LANG}}"

# Ensure our path is exported (in case callers modified PATH after earlier changes)
export PATH

# Debug summary at end of .zshenv load when debugging is enabled
if [[ "${ZSH_DEBUG}" == "1" ]]; then
  zf::debug "[DEBUG] .zshenv completed: ZDOTDIR=${ZDOTDIR} ZSH_CACHE_DIR=${ZSH_CACHE_DIR} ZSH_LOG_DIR=${ZSH_LOG_DIR} PATH=${PATH}" >> "${ZSH_DEBUG_LOG}" 2>/dev/null || true
fi

# End of .zshenv
