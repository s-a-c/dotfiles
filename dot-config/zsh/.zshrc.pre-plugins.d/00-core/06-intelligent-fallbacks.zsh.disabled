# Intelligent Fallback Systems for .NG Architecture
# This file provides smart fallback selection and graceful degradation strategies
# File: 35-intelligent-fallbacks.zsh
# Target: Smart fallback systems integrated into .ng core

[[ "$ZSH_DEBUG" == "1" ]] && {
    printf "# ++++++ %s ++++++++++++++++++++++++++++++++++++\n" "$0" >&2
}

# =============================================================================
# INTELLIGENT FALLBACK SYSTEMS (.NG-NATIVE)
# =============================================================================
# Provides smart fallback selection, graceful degradation, and context-aware
# error handling integrated into the .ng architecture

# Global intelligent fallback registry
typeset -gA _NG_FALLBACK_STRATEGIES
typeset -gA _NG_FALLBACK_CONTEXTS
typeset -gA _NG_FALLBACK_SUCCESS_RATES
typeset -ga _NG_ACTIVE_FALLBACKS
typeset -ga _NG_FALLBACK_HISTORY

# Intelligent .ng fallback selection
select_intelligent_ng_fallback() {
    local primary_system="$1"
    local failure_reason="$2"
    local context="${3:-general}"

    [[ "$ZSH_DEBUG" == "1" ]] && echo "# [FALLBACK] Selecting intelligent fallback for: $primary_system (reason: $failure_reason)" >&2

    local fallback_selected=""
    local fallback_priority=0

    # Define intelligent fallback strategies based on system and context
    case "$primary_system" in
        "path_management")
            case "$failure_reason" in
                "corruption"|"missing_directories")
                    fallback_selected="emergency_path_reconstruction"
                    fallback_priority=1
                    ;;
                "permission_issues")
                    fallback_selected="safe_path_alternative"
                    fallback_priority=2
                    ;;
                "performance_issues")
                    fallback_selected="minimal_path_configuration"
                    fallback_priority=3
                    ;;
                *)
                    fallback_selected="basic_path_fallback"
                    fallback_priority=4
                    ;;
            esac
            ;;
        "command_system")
            case "$failure_reason" in
                "missing_critical_commands")
                    fallback_selected="alternative_command_providers"
                    fallback_priority=1
                    ;;
                "command_not_found")
                    fallback_selected="function_based_alternatives"
                    fallback_priority=2
                    ;;
                "permission_denied")
                    fallback_selected="user_space_alternatives"
                    fallback_priority=3
                    ;;
                *)
                    fallback_selected="minimal_command_set"
                    fallback_priority=4
                    ;;
            esac
            ;;
        "plugin_system")
            case "$failure_reason" in
                "dependency_conflicts")
                    fallback_selected="conflict_free_subset"
                    fallback_priority=1
                    ;;
                "loading_failures")
                    fallback_selected="essential_plugins_only"
                    fallback_priority=2
                    ;;
                "performance_impact")
                    fallback_selected="lazy_loading_fallback"
                    fallback_priority=3
                    ;;
                *)
                    fallback_selected="minimal_plugin_configuration"
                    fallback_priority=4
                    ;;
            esac
            ;;
        "completion_system")
            case "$failure_reason" in
                "cache_corruption")
                    fallback_selected="cache_free_completion"
                    fallback_priority=1
                    ;;
                "performance_issues")
                    fallback_selected="basic_completion_only"
                    fallback_priority=2
                    ;;
                "initialization_failure")
                    fallback_selected="manual_completion_setup"
                    fallback_priority=3
                    ;;
                *)
                    fallback_selected="minimal_completion"
                    fallback_priority=4
                    ;;
            esac
            ;;
        "environment_system")
            case "$failure_reason" in
                "variable_corruption")
                    fallback_selected="environment_reconstruction"
                    fallback_priority=1
                    ;;
                "permission_issues")
                    fallback_selected="user_only_environment"
                    fallback_priority=2
                    ;;
                "validation_failures")
                    fallback_selected="basic_environment_setup"
                    fallback_priority=3
                    ;;
                *)
                    fallback_selected="minimal_environment"
                    fallback_priority=4
                    ;;
            esac
            ;;
    esac

    # Store fallback selection
    _NG_FALLBACK_STRATEGIES["$primary_system"]="$fallback_selected"
    _NG_FALLBACK_CONTEXTS["$primary_system"]="$context"
    _NG_ACTIVE_FALLBACKS+=("$primary_system:$fallback_selected")

    [[ "$ZSH_DEBUG" == "1" ]] && {
        echo "# [FALLBACK] Selected fallback: $fallback_selected (priority: $fallback_priority)" >&2
    }

    # Execute the selected fallback
    execute_ng_fallback_strategy "$primary_system" "$fallback_selected" "$context"

    return 0
}

# Execute .ng fallback strategies
execute_ng_fallback_strategy() {
    local system="$1"
    local strategy="$2"
    local context="$3"

    [[ "$ZSH_DEBUG" == "1" ]] && echo "# [FALLBACK] Executing fallback strategy: $strategy for $system" >&2

    local execution_success=false

    case "$strategy" in
        "emergency_path_reconstruction")
            echo "# [FALLBACK] Executing emergency PATH reconstruction..." >&2
            # Rebuild PATH with only essential system directories
            export PATH="/usr/bin:/bin:/usr/sbin:/sbin"

            # Add critical directories if they exist
            [[ -d "/usr/local/bin" ]] && export PATH="$PATH:/usr/local/bin"
            [[ -d "/opt/homebrew/bin" ]] && export PATH="$PATH:/opt/homebrew/bin"

            # Verify basic commands are available
            if command -v ls >/dev/null 2>&1 && command -v cat >/dev/null 2>&1; then
                echo "# [FALLBACK] SUCCESS: Emergency PATH reconstruction completed" >&2
                execution_success=true
            fi
            ;;
        "safe_path_alternative")
            echo "# [FALLBACK] Implementing safe PATH alternative..." >&2
            # Use a minimal but safe PATH configuration
            export PATH="/usr/bin:/bin${PATH:+:$PATH}"
            execution_success=true
            ;;
        "minimal_path_configuration")
            echo "# [FALLBACK] Applying minimal PATH configuration..." >&2
            # Use absolute minimal PATH for performance
            export PATH="/usr/bin:/bin"
            execution_success=true
            ;;
        "basic_path_fallback")
            echo "# [FALLBACK] Using basic PATH fallback..." >&2
            # Simple PATH restoration
            export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin"
            execution_success=true
            ;;
        "alternative_command_providers")
            echo "# [FALLBACK] Setting up alternative command providers..." >&2
            # Create function-based alternatives for missing commands
            setup_alternative_command_functions
            execution_success=true
            ;;
        "function_based_alternatives")
            echo "# [FALLBACK] Creating function-based command alternatives..." >&2
            # Create safe function wrappers for missing commands
            create_safe_command_wrappers
            execution_success=true
            ;;
        "user_space_alternatives")
            echo "# [FALLBACK] Setting up user space command alternatives..." >&2
            # Set up user-space alternatives where possible
            setup_user_space_commands
            execution_success=true
            ;;
        "minimal_command_set")
            echo "# [FALLBACK] Configuring minimal command set..." >&2
            # Ensure only essential commands are available
            validate_minimal_command_set
            execution_success=true
            ;;
        "conflict_free_subset")
            echo "# [FALLBACK] Loading conflict-free plugin subset..." >&2
            # Load only plugins that don't conflict
            load_conflict_free_plugins
            execution_success=true
            ;;
        "essential_plugins_only")
            echo "# [FALLBACK] Loading essential plugins only..." >&2
            # Load only absolutely essential plugins
            load_essential_plugins_only
            execution_success=true
            ;;
        "lazy_loading_fallback")
            echo "# [FALLBACK] Implementing lazy loading fallback..." >&2
            # Defer all non-essential plugin loading
            setup_lazy_plugin_loading
            execution_success=true
            ;;
        "minimal_plugin_configuration")
            echo "# [FALLBACK] Using minimal plugin configuration..." >&2
            # Disable all non-essential plugins
            disable_non_essential_plugins
            execution_success=true
            ;;
        "cache_free_completion")
            echo "# [FALLBACK] Setting up cache-free completion..." >&2
            # Set up completion without caching
            setup_cache_free_completion
            execution_success=true
            ;;
        "basic_completion_only")
            echo "# [FALLBACK] Configuring basic completion only..." >&2
            # Use only basic completion features
            setup_basic_completion
            execution_success=true
            ;;
        "manual_completion_setup")
            echo "# [FALLBACK] Implementing manual completion setup..." >&2
            # Manual completion initialization
            setup_manual_completion
            execution_success=true
            ;;
        "minimal_completion")
            echo "# [FALLBACK] Using minimal completion..." >&2
            # Absolute minimal completion setup
            setup_minimal_completion
            execution_success=true
            ;;
        "environment_reconstruction")
            echo "# [FALLBACK] Reconstructing environment..." >&2
            # Rebuild environment from scratch
            reconstruct_environment_variables
            execution_success=true
            ;;
        "user_only_environment")
            echo "# [FALLBACK] Setting up user-only environment..." >&2
            # Use only user-space environment settings
            setup_user_only_environment
            execution_success=true
            ;;
        "basic_environment_setup")
            echo "# [FALLBACK] Applying basic environment setup..." >&2
            # Use basic environment configuration
            setup_basic_environment
            execution_success=true
            ;;
        "minimal_environment")
            echo "# [FALLBACK] Using minimal environment..." >&2
            # Absolute minimal environment
            setup_minimal_environment
            execution_success=true
            ;;
        *)
            echo "# [FALLBACK] WARNING: Unknown fallback strategy: $strategy" >&2
            execution_success=false
            ;;
    esac

    # Record execution result
    if [[ "$execution_success" == "true" ]]; then
        _NG_FALLBACK_HISTORY+=("$(date +%s):$system:$strategy:success")
        echo "# [FALLBACK] SUCCESS: Fallback strategy '$strategy' executed successfully" >&2
    else
        _NG_FALLBACK_HISTORY+=("$(date +%s):$system:$strategy:failed")
        echo "# [FALLBACK] FAILED: Fallback strategy '$strategy' execution failed" >&2
    fi

    return $([[ "$execution_success" == "true" ]] && echo 0 || echo 1)
}

# Set up alternative command functions
setup_alternative_command_functions() {
    # Create intelligent alternatives for common missing commands

    # Alternative for uname
    if ! command -v uname >/dev/null 2>&1; then
        uname() {
            case "${1:-}" in
                "-s") echo "Darwin" ;;  # Assume macOS in this context
                "-m") echo "$(arch 2>/dev/null || echo "x86_64")" ;;
                "-r") echo "$(sw_vers -productVersion 2>/dev/null || echo "unknown")" ;;
                *) echo "Darwin" ;;
            esac
        }
        typeset -gf uname
    fi

    # Alternative for sed
    if ! command -v sed >/dev/null 2>&1; then
        sed() {
            echo "# [FALLBACK] sed not available - using basic text processing" >&2
            case "${1:-}" in
                "s/"*)
                    # Very basic substitution using parameter expansion
                    local input
                    if [[ -t 0 ]]; then
                        input="$2"
                    else
                        input=$(cat)
                    fi
                    echo "$input"  # Return unchanged for now
                    ;;
                *) echo "sed fallback: limited functionality" >&2 ;;
            esac
        }
        typeset -gf sed
    fi

    # Alternative for tr
    # Commented out - tr should be available on all systems
    # if ! command -v tr >/dev/null 2>&1; then
    #     tr() {
    #         echo "# [FALLBACK] tr not available - using basic character processing" >&2
    #         cat  # Pass through unchanged
    #     }
    #     typeset -gf tr
    # fi

    return 0
}

# Create safe command wrappers
create_safe_command_wrappers() {
    # Create wrappers that check for command availability before execution

    local -a critical_commands=("git" "curl" "wget" "make" "cc")

    for cmd in "${critical_commands[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            eval "
            $cmd() {
                echo \"# [FALLBACK] Command '$cmd' not available\" >&2
                echo \"# [FALLBACK] Suggestion: Install development tools or check PATH\" >&2
                return 127
            }
            "
            typeset -gf "$cmd"
        fi
    done

    return 0
}

# Set up user space commands
setup_user_space_commands() {
    # Check for user-installed alternatives

    local -a user_paths=(
        "$HOME/.local/bin"
        "$HOME/bin"
        "$HOME/.cargo/bin"
        "$HOME/.npm/bin"
    )

    for user_path in "${user_paths[@]}"; do
        if [[ -d "$user_path" ]] && [[ ":$PATH:" != *":$user_path:"* ]]; then
            export PATH="$user_path:$PATH"
            [[ "$ZSH_DEBUG" == "1" ]] && echo "# [FALLBACK] Added user path: $user_path" >&2
        fi
    done

    return 0
}

# Validate minimal command set
validate_minimal_command_set() {
    local -a minimal_commands=("ls" "cat" "echo" "cd" "pwd")
    local missing_count=0

    for cmd in "${minimal_commands[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            echo "# [FALLBACK] CRITICAL: Minimal command missing: $cmd" >&2
            ((missing_count++))
        fi
    done

    if [[ "$missing_count" -eq 0 ]]; then
        echo "# [FALLBACK] SUCCESS: All minimal commands available" >&2
        return 0
    else
        echo "# [FALLBACK] WARNING: $missing_count minimal commands missing" >&2
        return 1
    fi
}

# Load conflict-free plugins
load_conflict_free_plugins() {
    # Define safe, conflict-free plugins
    local -a safe_plugins=(
        "lib/history"
        "lib/key-bindings"
        "lib/completion"
    )

    echo "# [FALLBACK] Loading conflict-free plugin subset..." >&2
    # This would integrate with the plugin system
    # For now, just record that we're using safe mode
    export _NG_FALLBACK_PLUGIN_MODE="conflict_free"

    return 0
}

# Load essential plugins only
load_essential_plugins_only() {
    # Define absolutely essential plugins
    local -a essential_plugins=(
        "lib/history"
        "lib/completion"
    )

    echo "# [FALLBACK] Loading essential plugins only..." >&2
    export _NG_FALLBACK_PLUGIN_MODE="essential_only"

    return 0
}

# Set up lazy plugin loading
setup_lazy_plugin_loading() {
    echo "# [FALLBACK] Setting up lazy plugin loading..." >&2
    export _NG_FALLBACK_PLUGIN_MODE="lazy_loading"

    # Defer non-essential plugin loading
    export _NG_LAZY_LOADING_ENABLED="true"

    return 0
}

# Disable non-essential plugins
disable_non_essential_plugins() {
    echo "# [FALLBACK] Disabling non-essential plugins..." >&2
    export _NG_FALLBACK_PLUGIN_MODE="minimal"

    # Set flags to disable various plugin categories
    export _NG_DISABLE_SYNTAX_HIGHLIGHTING="true"
    export _NG_DISABLE_AUTOSUGGESTIONS="true"
    export _NG_DISABLE_THEMES="true"

    return 0
}

# Set up cache-free completion
setup_cache_free_completion() {
    echo "# [FALLBACK] Setting up cache-free completion..." >&2

    # Disable completion caching
    unset ZSH_COMPDUMP
    export _NG_COMPLETION_CACHE_DISABLED="true"

    # Basic completion setup without caching
    if autoload -Uz compinit 2>/dev/null; then
        compinit -C  # Skip security check for speed
    fi

    return 0
}

# Set up basic completion
setup_basic_completion() {
    echo "# [FALLBACK] Setting up basic completion..." >&2

    # Minimal completion configuration
    if autoload -Uz compinit 2>/dev/null; then
        compinit
    fi

    # Basic completion styles only
    zstyle ':completion:*' menu select

    return 0
}

# Set up manual completion
setup_manual_completion() {
    echo "# [FALLBACK] Setting up manual completion..." >&2

    # Manual completion initialization without automation
    autoload -Uz compinit 2>/dev/null && compinit

    return 0
}

# Set up minimal completion
setup_minimal_completion() {
    echo "# [FALLBACK] Setting up minimal completion..." >&2

    # Absolute minimal completion - just enable basic tab completion
    autoload -Uz compinit 2>/dev/null && compinit -C

    return 0
}

# Reconstruct environment variables
reconstruct_environment_variables() {
    echo "# [FALLBACK] Reconstructing environment variables..." >&2

    # Set essential environment variables
    [[ -z "$HOME" ]] && export HOME="$(eval echo ~$USER)"
    [[ -z "$USER" ]] && export USER="$(whoami 2>/dev/null || echo 'user')"
    [[ -z "$SHELL" ]] && export SHELL="/bin/zsh"

    # Set basic XDG directories
    export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
    export XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
    export XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"

    return 0
}

# Set up user-only environment
setup_user_only_environment() {
    echo "# [FALLBACK] Setting up user-only environment..." >&2

    # Use only user-accessible environment settings
    export ZDOTDIR="${XDG_CONFIG_HOME:-$HOME/.config}/zsh"

    # Basic shell options
    setopt AUTO_CD
    setopt INTERACTIVE_COMMENTS

    return 0
}

# Set up basic environment
setup_basic_environment() {
    echo "# [FALLBACK] Setting up basic environment..." >&2

    # Basic shell configuration
    setopt AUTO_CD
    setopt COMPLETE_IN_WORD
    setopt INTERACTIVE_COMMENTS

    # Basic history configuration
    export HISTSIZE=1000
    export SAVEHIST=1000
    export HISTFILE="${ZDOTDIR:-$HOME}/.zsh_history"

    return 0
}

# Set up minimal environment
setup_minimal_environment() {
    echo "# [FALLBACK] Setting up minimal environment..." >&2

    # Absolute minimal environment setup
    export HISTSIZE=100
    export SAVEHIST=100

    return 0
}

# Graceful .ng degradation for missing tools
graceful_ng_degradation() {
    local missing_tool="$1"
    local degradation_level="$2"

    [[ "$ZSH_DEBUG" == "1" ]] && echo "# [FALLBACK] Graceful degradation for missing tool: $missing_tool" >&2

    case "$missing_tool" in
        "git")
            echo "# [FALLBACK] Git not available - disabling git-related features" >&2
            export _NG_GIT_DISABLED="true"
            ;;
        "fzf")
            echo "# [FALLBACK] FZF not available - using basic selection" >&2
            export _NG_FZF_DISABLED="true"
            ;;
        "brew")
            echo "# [FALLBACK] Homebrew not available - using system package manager" >&2
            export _NG_HOMEBREW_DISABLED="true"
            ;;
        "node"|"npm")
            echo "# [FALLBACK] Node.js not available - disabling Node.js features" >&2
            export _NG_NODEJS_DISABLED="true"
            ;;
        *)
            echo "# [FALLBACK] Tool '$missing_tool' not available - graceful fallback applied" >&2
            ;;
    esac

    return 0
}

# Context-aware .ng error handling
handle_ng_context_aware_errors() {
    local error_type="$1"
    local error_context="$2"
    local recovery_strategy=""

    [[ "$ZSH_DEBUG" == "1" ]] && echo "# [FALLBACK] Context-aware error handling: $error_type in $error_context" >&2

    case "$error_context" in
        "startup")
            case "$error_type" in
                "command_not_found")
                    recovery_strategy="create_command_fallbacks"
                    ;;
                "permission_denied")
                    recovery_strategy="use_user_alternatives"
                    ;;
                "file_not_found")
                    recovery_strategy="create_minimal_config"
                    ;;
                *)
                    recovery_strategy="graceful_startup_degradation"
                    ;;
            esac
            ;;
        "plugin_loading")
            case "$error_type" in
                "dependency_missing")
                    recovery_strategy="skip_dependent_plugins"
                    ;;
                "conflict_detected")
                    recovery_strategy="resolve_plugin_conflicts"
                    ;;
                "loading_timeout")
                    recovery_strategy="defer_slow_plugins"
                    ;;
                *)
                    recovery_strategy="minimal_plugin_set"
                    ;;
            esac
            ;;
        "completion")
            case "$error_type" in
                "cache_corruption")
                    recovery_strategy="rebuild_completion_cache"
                    ;;
                "initialization_failure")
                    recovery_strategy="manual_completion_init"
                    ;;
                *)
                    recovery_strategy="basic_completion_fallback"
                    ;;
            esac
            ;;
        *)
            recovery_strategy="general_error_recovery"
            ;;
    esac

    # Execute the determined recovery strategy
    execute_recovery_strategy "$recovery_strategy" "$error_type" "$error_context"

    return 0
}

# Execute recovery strategy
execute_recovery_strategy() {
    local strategy="$1"
    local error_type="$2"
    local context="$3"

    [[ "$ZSH_DEBUG" == "1" ]] && echo "# [FALLBACK] Executing recovery strategy: $strategy" >&2

    case "$strategy" in
        "create_command_fallbacks")
            setup_alternative_command_functions
            ;;
        "use_user_alternatives")
            setup_user_space_commands
            ;;
        "create_minimal_config")
            setup_minimal_environment
            ;;
        "graceful_startup_degradation")
            echo "# [FALLBACK] Applying graceful startup degradation..." >&2
            export _NG_DEGRADED_MODE="true"
            ;;
        "skip_dependent_plugins")
            echo "# [FALLBACK] Skipping plugins with missing dependencies..." >&2
            export _NG_SKIP_DEPENDENT_PLUGINS="true"
            ;;
        "resolve_plugin_conflicts")
            load_conflict_free_plugins
            ;;
        "defer_slow_plugins")
            setup_lazy_plugin_loading
            ;;
        "minimal_plugin_set")
            disable_non_essential_plugins
            ;;
        "rebuild_completion_cache")
            setup_cache_free_completion
            ;;
        "manual_completion_init")
            setup_manual_completion
            ;;
        "basic_completion_fallback")
            setup_basic_completion
            ;;
        "general_error_recovery")
            echo "# [FALLBACK] Applying general error recovery..." >&2
            export _NG_GENERAL_FALLBACK_ACTIVE="true"
            ;;
        *)
            echo "# [FALLBACK] WARNING: Unknown recovery strategy: $strategy" >&2
            ;;
    esac

    return 0
}

# Smart .ng recovery strategies
implement_smart_ng_recovery() {
    local failure_pattern="$1"

    [[ "$ZSH_DEBUG" == "1" ]] && echo "# [FALLBACK] Implementing smart recovery for pattern: $failure_pattern" >&2

    case "$failure_pattern" in
        "cascading_failures")
            echo "# [FALLBACK] Detected cascading failures - implementing emergency mode" >&2
            export _NG_EMERGENCY_MODE="true"

            # Switch to absolute minimal configuration
            setup_minimal_environment
            disable_non_essential_plugins
            setup_minimal_completion
            ;;
        "performance_degradation")
            echo "# [FALLBACK] Performance degradation detected - optimizing for speed" >&2
            export _NG_PERFORMANCE_MODE="true"

            # Enable performance optimizations
            setup_lazy_plugin_loading
            setup_cache_free_completion
            ;;
        "resource_exhaustion")
            echo "# [FALLBACK] Resource exhaustion detected - reducing resource usage" >&2
            export _NG_RESOURCE_CONSTRAINED_MODE="true"

            # Minimize resource usage
            disable_non_essential_plugins
            setup_minimal_completion
            ;;
        *)
            echo "# [FALLBACK] General smart recovery applied" >&2
            export _NG_SMART_RECOVERY_ACTIVE="true"
            ;;
    esac

    return 0
}

# Minimal impact .ng fallback operations
execute_minimal_impact_fallbacks() {
    [[ "$ZSH_DEBUG" == "1" ]] && echo "# [FALLBACK] Executing minimal impact fallback operations..." >&2

    local operations_executed=0

    # Only execute fallbacks that have minimal performance impact

    # Check if we can safely optimize PATH
    if [[ "${#PATH}" -gt 500 ]]; then
        # PATH is very long, safe to optimize
        export PATH="/usr/bin:/bin:/usr/local/bin${PATH:+:$PATH}"
        ((operations_executed++))
    fi

    # Check if we can safely disable expensive features
    if [[ -z "$_NG_PERFORMANCE_MODE" ]]; then
        # Safe to make minor performance adjustments
        export _NG_MINIMAL_IMPACT_MODE="true"
        ((operations_executed++))
    fi

    [[ "$ZSH_DEBUG" == "1" ]] && {
        echo "# [FALLBACK] Minimal impact operations complete: $operations_executed executed" >&2
    }

    return 0
}

# Intelligent fallback diagnostics
ng_fallback_doctor() {
    echo "ðŸ›¡ï¸ .NG Intelligent Fallback Systems - Status Report"
    echo "=================================================="
    echo

    echo "ðŸ”„ Active Fallbacks:"
    if [[ "${#_NG_ACTIVE_FALLBACKS[@]}" -gt 0 ]]; then
        for fallback in "${_NG_ACTIVE_FALLBACKS[@]}"; do
            echo "  âœ“ $fallback"
        done
    else
        echo "  No active fallbacks (system operating normally)"
    fi
    echo

    echo "ðŸ“Š Fallback Strategies:"
    for system in "${!_NG_FALLBACK_STRATEGIES[@]}"; do
        echo "  â€¢ $system: ${_NG_FALLBACK_STRATEGIES[$system]}"
    done
    echo

    echo "ðŸ” System Status Flags:"
    [[ -n "$_NG_DEGRADED_MODE" ]] && echo "  âš ï¸ Degraded Mode: Active"
    [[ -n "$_NG_EMERGENCY_MODE" ]] && echo "  ðŸš¨ Emergency Mode: Active"
    [[ -n "$_NG_PERFORMANCE_MODE" ]] && echo "  ðŸš€ Performance Mode: Active"
    [[ -n "$_NG_RESOURCE_CONSTRAINED_MODE" ]] && echo "  ðŸ’¾ Resource Constrained Mode: Active"
    [[ -n "$_NG_MINIMAL_IMPACT_MODE" ]] && echo "  ðŸ”§ Minimal Impact Mode: Active"

    # Show normal operation if no special modes
    if [[ -z "$_NG_DEGRADED_MODE$_NG_EMERGENCY_MODE$_NG_PERFORMANCE_MODE$_NG_RESOURCE_CONSTRAINED_MODE$_NG_MINIMAL_IMPACT_MODE" ]]; then
        echo "  âœ… Normal Operation Mode: Active"
    fi
    echo

    echo "ðŸ“ˆ Fallback History (Recent):"
    if [[ "${#_NG_FALLBACK_HISTORY[@]}" -gt 0 ]]; then
        local recent_count=0
        for entry in "${_NG_FALLBACK_HISTORY[@]}"; do
            if [[ "$recent_count" -lt 5 ]]; then
                local timestamp="${entry%%:*}"
                local details="${entry#*:}"
                echo "  â€¢ $(date -r "$timestamp" '+%H:%M:%S'): $details"
                ((recent_count++))
            fi
        done
    else
        echo "  No fallback history recorded"
    fi
    echo

    echo "ðŸ’¡ Recommendations:"
    if [[ -n "$_NG_EMERGENCY_MODE" ]]; then
        echo "  ðŸš¨ System in emergency mode - investigate critical issues"
        echo "  â€¢ Run comprehensive system diagnostics"
        echo "  â€¢ Consider manual intervention for persistent issues"
    elif [[ -n "$_NG_DEGRADED_MODE" ]]; then
        echo "  âš ï¸ System operating in degraded mode"
        echo "  â€¢ Address underlying issues when possible"
        echo "  â€¢ Monitor system stability"
    else
        echo "  âœ… Fallback systems ready and operational"
        echo "  â€¢ No immediate action required"
    fi

    return 0
}

# =============================================================================
# INITIALIZE INTELLIGENT FALLBACK SYSTEMS
# =============================================================================

[[ "$ZSH_DEBUG" == "1" ]] && echo "# [FALLBACK] Initializing intelligent fallback systems..." >&2

# Execute minimal impact fallback checks
execute_minimal_impact_fallbacks

# Export functions for use by other .ng systems
typeset -gf select_intelligent_ng_fallback execute_ng_fallback_strategy
typeset -gf graceful_ng_degradation handle_ng_context_aware_errors
typeset -gf implement_smart_ng_recovery execute_minimal_impact_fallbacks
typeset -gf ng_fallback_doctor

[[ "$ZSH_DEBUG" == "1" ]] && echo "# [FALLBACK] Intelligent fallback systems initialized successfully" >&2

# =============================================================================
# .NG INTEGRATION STATUS
# =============================================================================
export _NG_INTELLIGENT_FALLBACKS_LOADED="true"
export _NG_FALLBACK_SYSTEM_VERSION="1.0.0"
