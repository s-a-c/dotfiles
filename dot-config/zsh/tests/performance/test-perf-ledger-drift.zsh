#!/usr/bin/env zsh
# =============================================================================
# test-perf-ledger-drift.zsh
#
# Purpose:
#   Compare the current performance ledger JSON artifact against the most recent
#   historical snapshot (or an explicitly provided reference) and report drift
#   for selected segments. Provides early visibility into performance regressions
#   before hard gating is enabled.
#
# Inputs / Artifacts:
#   Current:  docs/redesignv2/artifacts/metrics/perf-ledger.json
#   History:  docs/redesignv2/artifacts/metrics/ledger-history/perf-ledger-YYYYMMDD.json
#
# Segment Source:
#   The perf ledger JSON generated by tools/experimental/perf-module-ledger.zsh
#   has structure:
#     {
#       "segments": {
#          "pre_plugin_total": {"ms": <number>, ...},
#          "post_plugin_total": {"ms": <number>, ...},
#          ...
#       },
#       ...
#     }
#
# Drift Calculation:
#   pct = ((current - previous) / previous) * 100
#   - Improvement (negative pct) is always PASS.
#   - If previous == 0 and current > 0 â†’ pct is undefined; reported as ABS(+current).
#
# Threshold Logic (per segment):
#   - pct > FAIL threshold      => FAIL
#   - pct > WARN threshold      => WARN (non-fatal)
#   - else                      => PASS
#
# Default Thresholds (can tune as variance stabilizes):
#   WARN: 7%
#   FAIL: 10%
#
# Environment Variables:
#   TDD_SKIP_PERF_LEDGER_DRIFT=1       Skip the test entirely.
#   PERF_LEDGER_FILE=path              Override current ledger file path.
#   PERF_LEDGER_HISTORY_DIR=path       Override history directory.
#   PERF_LEDGER_REF_FILE=path          Explicit reference ledger (bypass auto-discovery).
#   PERF_LEDGER_DRIFT_SEGMENTS="a b"   Space-separated segment names to compare
#                                      (default: "post_plugin_total pre_plugin_total prompt_ready").
#   PERF_LEDGER_DRIFT_WARN_PCT=7       Warn threshold (integer or float).
#   PERF_LEDGER_DRIFT_FAIL_PCT=10      Fail threshold.
#   PERF_LEDGER_REQUIRE_HISTORY=0      If 1, absence of history => SKIP as FAIL (infrastructure).
#   PERF_LEDGER_MIN_HISTORY_AGE_DAYS=0 Minimum age (in days) for history (0 = allow same-day).
#   PERF_LEDGER_ALLOW_MISSING_SEG=1    If 1, missing segment is WARN instead of FAIL.
#
# Exit Codes:
#   0 PASS (or SKIP)
#   1 FAIL (one or more failures)
#
# Output Format:
#   PASS:, WARN:, FAIL: lines
#   SUMMARY line
#   TEST RESULT: PASS|FAIL
#
# Future Enhancements (planned):
#   - Rolling average baseline selection
#   - Median/stdev context in drift messaging
#   - JSON emission for machine aggregation (promotion guard correlation)
#   - Integration with perf-diff results for combined gate signal
# =============================================================================

set -euo pipefail

# ---------------------------
# Skip Handling
# ---------------------------
if [[ "${TDD_SKIP_PERF_LEDGER_DRIFT:-0}" == "1" ]]; then
  print "SKIP: perf ledger drift test skipped (TDD_SKIP_PERF_LEDGER_DRIFT=1)"
  exit 0
fi

# ---------------------------
# Configuration / Defaults
# ---------------------------
: "${PERF_LEDGER_FILE:=docs/redesignv2/artifacts/metrics/perf-ledger.json}"
: "${PERF_LEDGER_HISTORY_DIR:=docs/redesignv2/artifacts/metrics/ledger-history}"
: "${PERF_LEDGER_DRIFT_SEGMENTS:=post_plugin_total pre_plugin_total prompt_ready}"
: "${PERF_LEDGER_DRIFT_WARN_PCT:=7}"
: "${PERF_LEDGER_DRIFT_FAIL_PCT:=10}"
: "${PERF_LEDGER_REQUIRE_HISTORY:=0}"
: "${PERF_LEDGER_MIN_HISTORY_AGE_DAYS:=0}"
: "${PERF_LEDGER_ALLOW_MISSING_SEG:=1}"

REF_FILE="${PERF_LEDGER_REF_FILE:-}"

PASS=()
FAIL=()
WARN=()
SKIP_FLAG=0

pass(){ PASS+=("$1"); }
fail(){ FAIL+=("$1"); }
warn(){ WARN+=("$1"); }

_has_jq=0
command -v jq >/dev/null 2>&1 && _has_jq=1

_ts_now_epoch() {
  date -u +%s 2>/dev/null || python - <<'PY' 2>/dev/null
import time; print(int(time.time()))
PY
}

# ---------------------------
# Helper: Read ms value for segment from ledger
# ---------------------------
get_segment_ms() {
  local file="$1" seg="$2" val=""
  [[ -f "$file" ]] || { print ""; return 0; }
  if (( _has_jq )); then
    val=$(jq -r --arg s "$seg" '.segments[$s].ms // empty' "$file" 2>/dev/null || true)
  else
    # Fallback naive parse (may fail on edge cases, acceptable for CI fallback)
    # Look for '"seg": {"ms": <number>'
    val=$(grep -E "\"$seg\"[[:space:]]*:[[:space:]]*\{[^}]*\"ms\"" "$file" 2>/dev/null | head -1 | sed -n 's/.*"ms"[[:space:]]*:[[:space:]]*\([0-9.]\+\).*/\1/p')
  fi
  print -- "$val"
}

# ---------------------------
# History Reference Discovery
# ---------------------------
_select_reference_file() {
  local ref_override="$1"
  local history_dir="$2"
  local min_age_days="$3"

  if [[ -n "$ref_override" ]]; then
    [[ -f "$ref_override" ]] || return 1
    print -- "$ref_override"
    return 0
  fi

  [[ -d "$history_dir" ]] || return 1

  local now=$(_ts_now_epoch)
  local min_age_sec=$(( min_age_days * 86400 ))

  # Collect candidate files
  local -a files
  files=(${history_dir}/perf-ledger-*.json(Nk))
  # ^ (N) nullglob, (k) keep order (lexicographic; date pattern ensures chronological)
  (( ${#files[@]} == 0 )) && return 1

  # Choose most recent file that satisfies age requirement and is not the *same* as current ledger (if paths differ)
  local f selected=""
  for f in ${(Oa)files}; do
    # Derive date from filename pattern perf-ledger-YYYYMMDD.json
    local base=${f:t}
    local ds=${base#perf-ledger-}
    ds=${ds%.json}
    # parse date: YYYYMMDD
    if [[ "$ds" =~ ^[0-9]{8}$ ]]; then
      local y=${ds[1,4]}
      local m=${ds[5,6]}
      local d=${ds[7,8]}
      # Convert to epoch (portable attempt)
      local epoch
      epoch=$(date -u -j -f "%Y%m%d" "${y}${m}${d}" "+%s" 2>/dev/null || date -u -d "${y}-${m}-${d}" "+%s" 2>/dev/null || echo 0)
      if [[ "$epoch" == "0" || -z "$epoch" ]]; then
        continue
      fi
      local age=$(( now - epoch ))
      if (( age >= min_age_sec )); then
        selected="$f"
        break
      fi
    fi
  done

  [[ -n "$selected" ]] || return 1
  print -- "$selected"
}

REF_PATH="$(_select_reference_file "$REF_FILE" "$PERF_LEDGER_HISTORY_DIR" "$PERF_LEDGER_MIN_HISTORY_AGE_DAYS" 2>/dev/null || true)"

if [[ ! -f "$PERF_LEDGER_FILE" ]]; then
  SKIP_FLAG=1
  warn "C1 current-ledger-missing ($PERF_LEDGER_FILE)"
fi

if [[ -z "$REF_PATH" ]]; then
  if (( PERF_LEDGER_REQUIRE_HISTORY == 1 )); then
    fail "C2 no-reference-history (required)"
  else
    warn "C2 no-reference-history (skipping drift evaluation)"
    SKIP_FLAG=1
  fi
else
  pass "C2 reference-selected=${REF_PATH:t}"
fi

if (( SKIP_FLAG == 1 )); then
  print "SKIP: insufficient data for drift evaluation"
  for w in "${WARN[@]}"; do print "WARN: $w"; done
  for f in "${FAIL[@]}"; do print "FAIL: $f"; done
  if (( ${#FAIL[@]} > 0 )); then
    print "TEST RESULT: FAIL"
    exit 1
  fi
  print "TEST RESULT: PASS"
  exit 0
fi

# ---------------------------
# Drift Evaluation
# ---------------------------
warn_pct="$PERF_LEDGER_DRIFT_WARN_PCT"
fail_pct="$PERF_LEDGER_DRIFT_FAIL_PCT"

float_regex='^[0-9]+([.][0-9]+)?$'

segment_list=(${=PERF_LEDGER_DRIFT_SEGMENTS})

for seg in "${segment_list[@]}"; do
  prev=$(get_segment_ms "$REF_PATH" "$seg")
  curr=$(get_segment_ms "$PERF_LEDGER_FILE" "$seg")

  if [[ -z "$curr" ]]; then
    if (( PERF_LEDGER_ALLOW_MISSING_SEG == 1 )); then
      warn "D-${seg} missing-current-segment"
      continue
    else
      fail "D-${seg} missing-current-segment"
      continue
    fi
  fi
  if [[ -z "$prev" ]]; then
    # No baseline for this segment
    warn "D-${seg} missing-reference-segment"
    continue
  fi

  # Validate numeric
  if ! [[ "$curr" =~ $float_regex ]]; then
    warn "D-${seg} non-numeric-current=${curr}"
    continue
  fi
  if ! [[ "$prev" =~ $float_regex ]]; then
    warn "D-${seg} non-numeric-reference=${prev}"
    continue
  fi

  # Calculate drift
  drift_label=""
  pct=""
  if awk -v p="$prev" 'BEGIN{exit (p==0?0:1)}'; then
    # previous == 0
    if awk -v c="$curr" 'BEGIN{exit (c==0?0:1)}'; then
      pct="0"
      drift_label="flat(0->0)"
      pass "D-${seg} flat prev=0 curr=0"
    else
      # Undefined percent; report absolute
      drift_label="abs_increase(prev=0 curr=${curr})"
      # treat as WARN (can't compute ratio)
      warn "D-${seg} ${drift_label}"
    fi
  else
    pct=$(awk -v c="$curr" -v p="$prev" 'BEGIN{printf "%.2f", ((c-p)/p)*100}')
    # Determine classification
    if awk -v x="$pct" 'BEGIN{exit (x<=0?0:1)}'; then
      pass "D-${seg} improvement pct=${pct}% prev=${prev} curr=${curr}"
    else
      # Positive drift (regression)
      if awk -v x="$pct" -v f="$fail_pct" 'BEGIN{exit (x>f?0:1)}'; then
        fail "D-${seg} regression pct=${pct}% prev=${prev} curr=${curr} (fail>${fail_pct}%)"
      elif awk -v x="$pct" -v w="$warn_pct" 'BEGIN{exit (x>w?0:1)}'; then
        warn "D-${seg} regression pct=${pct}% prev=${prev} curr=${curr} (warn>${warn_pct}%)"
      else
        pass "D-${seg} mild regression pct=${pct}% prev=${prev} curr=${curr}"
      fi
    fi
  fi
done

# ---------------------------
# Reporting
# ---------------------------
for p in "${PASS[@]}"; do print "PASS: $p"; done
for w in "${WARN[@]}"; do print "WARN: $w"; done
for f in "${FAIL[@]}"; do print "FAIL: $f"; done

print "---"
print "SUMMARY: segments=${#segment_list[@]} pass=${#PASS[@]} warn=${#WARN[@]} fail=${#FAIL[@]} ref=${REF_PATH:t}"

if (( ${#FAIL[@]} > 0 )); then
  print "TEST RESULT: FAIL"
  exit 1
fi

print "TEST RESULT: PASS"
exit 0
