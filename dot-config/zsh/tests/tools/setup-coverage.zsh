#!/usr/bin/env zsh
# dotfiles/dot-config/zsh/tests/tools/setup-coverage.zsh
#
# Coverage Tracking Setup for ZSH Configuration Tests
# Integrates kcov for code coverage analysis and report generation.
#
# Features:
# - Automated kcov configuration for ZSH scripts
# - Coverage report generation (HTML, JSON, XML)
# - Coverage badge generation
# - Integration with CI/CD pipelines
# - Incremental coverage tracking
# - Coverage threshold validation
#
# Usage:
#   ./setup-coverage.zsh [options]
#   source setup-coverage.zsh && coverage_run_test test-file.zsh
#
# Options:
#   --init              Initialize coverage tracking
#   --clean             Clean coverage data
#   --report            Generate coverage reports
#   --badge             Generate coverage badge
#   --threshold N       Set coverage threshold (default: 80)
#   --format FORMAT     Report format: html,json,xml,all (default: html)
#   --help              Show help
#

set -euo pipefail

# Configuration
SCRIPT_DIR="${${(%):-%x}:A:h}"
ZDOTDIR="${ZDOTDIR:-${XDG_CONFIG_HOME:-$HOME/.config}/zsh}"
COVERAGE_DIR="${ZDOTDIR}/tests/coverage"
COVERAGE_DATA_DIR="${COVERAGE_DIR}/data"
COVERAGE_REPORTS_DIR="${COVERAGE_DIR}/reports"
COVERAGE_CONFIG_FILE="${COVERAGE_DIR}/kcov.conf"
COVERAGE_THRESHOLD=80
COVERAGE_FORMAT="html"

# State
COVERAGE_INITIALIZED=0

# Colors for output
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' NC=''
fi

# Logging functions
coverage_log() {
    printf "[COVERAGE] %s\n" "$*"
}

coverage_debug() {
    if [[ "${COVERAGE_DEBUG:-0}" == "1" ]]; then
        printf "[COVERAGE DEBUG] %s\n" "$*" >&2
    fi
}

coverage_error() {
    printf "${RED}[COVERAGE ERROR]${NC} %s\n" "$*" >&2
}

coverage_success() {
    printf "${GREEN}[COVERAGE]${NC} %s\n" "$*"
}

coverage_warn() {
    printf "${YELLOW}[COVERAGE WARN]${NC} %s\n" "$*"
}

# Show help
coverage_show_help() {
    cat <<EOF
ZSH Configuration Coverage Tracking Setup

Usage: $0 [options]

Options:
  --init              Initialize coverage tracking
  --clean             Clean coverage data
  --report            Generate coverage reports
  --badge             Generate coverage badge
  --threshold N       Set coverage threshold (default: 80)
  --format FORMAT     Report format: html,json,xml,all (default: html)
  --exclude PATTERN   Exclude files matching pattern
  --include PATTERN   Include only files matching pattern
  --output DIR        Override output directory
  --verbose           Enable verbose output
  --help              Show this help

Examples:
  # Initialize coverage tracking
  $0 --init

  # Generate HTML coverage report
  $0 --report --format html

  # Generate all formats with 85% threshold
  $0 --report --format all --threshold 85

  # Clean and regenerate reports
  $0 --clean && $0 --report

Environment Variables:
  COVERAGE_DEBUG      Enable debug output (0/1)
  KCOV_OPTIONS        Additional kcov options
  COVERAGE_EXCLUDE    Default exclude patterns
EOF
}

# Check prerequisites
coverage_check_prerequisites() {
    local missing_tools=()

    # Check for kcov
    if ! command -v kcov >/dev/null 2>&1; then
        missing_tools+=("kcov")
    fi

    # Check for jq (for JSON processing)
    if ! command -v jq >/dev/null 2>&1; then
        coverage_warn "jq not found - JSON processing will be limited"
    fi

    if (( ${#missing_tools} > 0 )); then
        coverage_error "Missing required tools: ${missing_tools[*]}"
        coverage_log "Install with: brew install ${missing_tools[*]}"
        return 1
    fi

    return 0
}

# Initialize coverage tracking
coverage_init() {
    coverage_log "Initializing coverage tracking..."

    # Check prerequisites
    coverage_check_prerequisites || return 1

    # Create directories
    mkdir -p "$COVERAGE_DIR" "$COVERAGE_DATA_DIR" "$COVERAGE_REPORTS_DIR"

    # Create kcov configuration
    cat > "$COVERAGE_CONFIG_FILE" <<EOF
# kcov configuration for ZSH testing
# Generated by setup-coverage.zsh on $(date)

# Include patterns - focus on our ZSH configuration files
--include-pattern=${ZDOTDIR}
--include-pattern=${ZDOTDIR}/.zshrc.pre-plugins.d.REDESIGN
--include-pattern=${ZDOTDIR}/.zshrc.d.REDESIGN

# Exclude patterns - system files and external dependencies
--exclude-pattern=/usr
--exclude-pattern=/opt
--exclude-pattern=/nix
--exclude-pattern=/System
--exclude-pattern=${HOME}/.local
--exclude-pattern=${ZDOTDIR}/.zqs-zgenom
--exclude-pattern=${ZDOTDIR}/tests
--exclude-line-pattern=^#.*$
--exclude-line-pattern=^\s*$

# Output options
--html-include-title
--html-title="ZSH Configuration Coverage"
--json-mode
--xml-mode

# Behavior
--verify
--skip-solibs
--clean
EOF

    # Create coverage wrapper script
    cat > "$COVERAGE_DIR/run-with-coverage.zsh" <<'EOF'
#!/usr/bin/env zsh
# Coverage wrapper script
set -euo pipefail

COVERAGE_DIR="$(dirname "$0")"
source "$COVERAGE_DIR/../tools/setup-coverage.zsh"

if [[ $# -lt 1 ]]; then
    echo "Usage: $0 <test-script> [args...]"
    exit 1
fi

coverage_run_test "$@"
EOF
    chmod +x "$COVERAGE_DIR/run-with-coverage.zsh"

    # Create .gitignore for coverage data
    cat > "$COVERAGE_DIR/.gitignore" <<EOF
# Coverage data files
data/
reports/
*.info
*.gcov
*.gcda
*.gcno

# Keep configuration and tools
!kcov.conf
!run-with-coverage.zsh
!.gitignore
EOF

    COVERAGE_INITIALIZED=1
    coverage_success "Coverage tracking initialized in: $COVERAGE_DIR"
    coverage_log "Configuration file: $COVERAGE_CONFIG_FILE"
    coverage_log "Use 'coverage_run_test <script>' to run tests with coverage"

    return 0
}

# Clean coverage data
coverage_clean() {
    coverage_log "Cleaning coverage data..."

    if [[ -d "$COVERAGE_DATA_DIR" ]]; then
        rm -rf "$COVERAGE_DATA_DIR"/*
        coverage_success "Coverage data cleaned"
    fi

    if [[ -d "$COVERAGE_REPORTS_DIR" ]]; then
        rm -rf "$COVERAGE_REPORTS_DIR"/*
        coverage_success "Coverage reports cleaned"
    fi

    return 0
}

# Run a test with coverage tracking
coverage_run_test() {
    local test_script="$1"
    shift

    if [[ ! -f "$test_script" ]]; then
        coverage_error "Test script not found: $test_script"
        return 1
    fi

    local test_name="$(basename "$test_script" .zsh)"
    local output_dir="$COVERAGE_DATA_DIR/$test_name"
    local timestamp="$(date +%Y%m%d_%H%M%S)"

    coverage_debug "Running test with coverage: $test_script"
    coverage_debug "Output directory: $output_dir"

    # Ensure directories exist
    mkdir -p "$output_dir"

    # Build kcov command
    local kcov_cmd=(
        kcov
        --config-file="$COVERAGE_CONFIG_FILE"
        ${KCOV_OPTIONS:+${=KCOV_OPTIONS}}
        "$output_dir"
        zsh "$test_script" "$@"
    )

    coverage_debug "Running: ${kcov_cmd[*]}"

    # Run with coverage
    "${kcov_cmd[@]}" || {
        local exit_code=$?
        coverage_error "Test execution failed with exit code: $exit_code"
        return $exit_code
    }

    coverage_success "Coverage data collected for: $test_name"
    return 0
}

# Generate coverage reports
coverage_generate_reports() {
    local format="${1:-$COVERAGE_FORMAT}"
    local threshold="${2:-$COVERAGE_THRESHOLD}"

    coverage_log "Generating coverage reports (format: $format, threshold: $threshold%)..."

    if [[ ! -d "$COVERAGE_DATA_DIR" || -z "$(ls -A "$COVERAGE_DATA_DIR" 2>/dev/null)" ]]; then
        coverage_error "No coverage data found. Run tests with coverage first."
        return 1
    fi

    # Create timestamp-specific report directory
    local timestamp="$(date +%Y%m%d_%H%M%S)"
    local report_dir="$COVERAGE_REPORTS_DIR/$timestamp"
    mkdir -p "$report_dir"

    # Merge coverage data from all tests
    local merged_dir="$report_dir/merged"
    mkdir -p "$merged_dir"

    # Use kcov to merge data
    local merge_cmd=(
        kcov
        --config-file="$COVERAGE_CONFIG_FILE"
        --merge
        "$merged_dir"
        "$COVERAGE_DATA_DIR"/*
    )

    coverage_debug "Merging coverage data: ${merge_cmd[*]}"
    "${merge_cmd[@]}" || {
        coverage_error "Failed to merge coverage data"
        return 1
    }

    # Generate different format reports
    case "$format" in
        html|all)
            if [[ -f "$merged_dir/index.html" ]]; then
                cp -r "$merged_dir"/* "$report_dir/"
                coverage_success "HTML report: $report_dir/index.html"
            fi
            ;&
        json|all)
            if [[ -f "$merged_dir/coverage.json" ]]; then
                cp "$merged_dir/coverage.json" "$report_dir/"
                coverage_success "JSON report: $report_dir/coverage.json"
            fi
            ;&
        xml|all)
            if [[ -f "$merged_dir/cobertura.xml" ]]; then
                cp "$merged_dir/cobertura.xml" "$report_dir/"
                coverage_success "XML report: $report_dir/cobertura.xml"
            fi
            ;;
        *)
            coverage_error "Unknown format: $format"
            return 1
            ;;
    esac

    # Create symlink to latest report
    local latest_link="$COVERAGE_REPORTS_DIR/latest"
    rm -f "$latest_link"
    ln -sf "$timestamp" "$latest_link"

    # Extract and display coverage summary
    coverage_extract_summary "$report_dir" "$threshold"

    return 0
}

# Extract coverage summary
coverage_extract_summary() {
    local report_dir="$1"
    local threshold="$2"

    coverage_log "Coverage Summary:"

    # Try to extract from JSON first
    if [[ -f "$report_dir/coverage.json" ]] && command -v jq >/dev/null 2>&1; then
        local line_coverage
        line_coverage=$(jq -r '.line_coverage // "N/A"' "$report_dir/coverage.json" 2>/dev/null || echo "N/A")

        if [[ "$line_coverage" != "N/A" ]]; then
            local coverage_pct=$(echo "$line_coverage * 100" | bc -l 2>/dev/null | cut -d. -f1)
            coverage_log "  Line Coverage: ${coverage_pct}%"

            if (( coverage_pct >= threshold )); then
                coverage_success "  ✅ Coverage threshold met (${coverage_pct}% >= ${threshold}%)"
            else
                coverage_error "  ❌ Coverage threshold not met (${coverage_pct}% < ${threshold}%)"
                return 1
            fi
        fi
    fi

    # Try to extract from HTML
    if [[ -f "$report_dir/index.html" ]]; then
        local html_summary
        html_summary=$(grep -o 'Lines:.*%' "$report_dir/index.html" 2>/dev/null | head -n1 || echo "")
        if [[ -n "$html_summary" ]]; then
            coverage_log "  $html_summary"
        fi
    fi

    coverage_log "  Report directory: $report_dir"
    return 0
}

# Generate coverage badge
coverage_generate_badge() {
    local report_dir="$COVERAGE_REPORTS_DIR/latest"
    local badge_file="$COVERAGE_DIR/coverage-badge.svg"

    if [[ ! -d "$report_dir" ]]; then
        coverage_error "No coverage reports found. Generate reports first."
        return 1
    fi

    coverage_log "Generating coverage badge..."

    # Extract coverage percentage
    local coverage_pct="0"
    if [[ -f "$report_dir/coverage.json" ]] && command -v jq >/dev/null 2>&1; then
        local line_coverage
        line_coverage=$(jq -r '.line_coverage // "0"' "$report_dir/coverage.json" 2>/dev/null || echo "0")
        coverage_pct=$(echo "$line_coverage * 100" | bc -l 2>/dev/null | cut -d. -f1)
    fi

    # Determine badge color
    local badge_color="red"
    if (( coverage_pct >= 90 )); then
        badge_color="brightgreen"
    elif (( coverage_pct >= 80 )); then
        badge_color="green"
    elif (( coverage_pct >= 70 )); then
        badge_color="yellow"
    elif (( coverage_pct >= 60 )); then
        badge_color="orange"
    fi

    # Generate SVG badge
    cat > "$badge_file" <<EOF
<svg xmlns="http://www.w3.org/2000/svg" width="104" height="20">
  <linearGradient id="b" x2="0" y2="100%">
    <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
    <stop offset="1" stop-opacity=".1"/>
  </linearGradient>
  <mask id="a">
    <rect width="104" height="20" rx="3" fill="white"/>
  </mask>
  <g mask="url(#a)">
    <path fill="#555" d="M0 0h63v20H0z"/>
    <path fill="$badge_color" d="M63 0h41v20H63z"/>
    <path fill="url(#b)" d="M0 0h104v20H0z"/>
  </g>
  <g fill="#fff" text-anchor="middle" font-family="DejaVu Sans,Verdana,Geneva,sans-serif" font-size="11">
    <text x="31.5" y="15" fill="#010101" fill-opacity=".3">coverage</text>
    <text x="31.5" y="14">coverage</text>
    <text x="82.5" y="15" fill="#010101" fill-opacity=".3">${coverage_pct}%</text>
    <text x="82.5" y="14">${coverage_pct}%</text>
  </g>
</svg>
EOF

    coverage_success "Coverage badge generated: $badge_file (${coverage_pct}%)"
    return 0
}

# Main execution
coverage_main() {
    local action=""
    local format="$COVERAGE_FORMAT"
    local threshold="$COVERAGE_THRESHOLD"
    local clean_first=0

    # Parse arguments
    while (( $# > 0 )); do
        case "$1" in
            --init)
                action="init"
                ;;
            --clean)
                if [[ -z "$action" ]]; then
                    action="clean"
                else
                    clean_first=1
                fi
                ;;
            --report)
                action="report"
                ;;
            --badge)
                action="badge"
                ;;
            --threshold)
                shift
                threshold="$1"
                ;;
            --format)
                shift
                format="$1"
                ;;
            --verbose)
                export COVERAGE_DEBUG=1
                ;;
            --help)
                coverage_show_help
                return 0
                ;;
            *)
                coverage_error "Unknown option: $1"
                coverage_show_help
                return 1
                ;;
        esac
        shift
    done

    # Default action
    if [[ -z "$action" ]]; then
        coverage_show_help
        return 1
    fi

    # Clean first if requested
    if (( clean_first )); then
        coverage_clean || return 1
    fi

    # Execute action
    case "$action" in
        init)
            coverage_init
            ;;
        clean)
            coverage_clean
            ;;
        report)
            coverage_generate_reports "$format" "$threshold"
            ;;
        badge)
            coverage_generate_badge
            ;;
        *)
            coverage_error "Unknown action: $action"
            return 1
            ;;
    esac
}

# If script is run directly (not sourced)
# Use ZSH-specific method to detect if script is being executed vs sourced
if [[ "${ZSH_EVAL_CONTEXT:-}" == toplevel || "${ZSH_EVAL_CONTEXT:-}" == cmdarg* ]]; then
    coverage_main "$@"
fi
