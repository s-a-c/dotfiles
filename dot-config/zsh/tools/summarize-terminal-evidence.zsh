#!/usr/bin/env zsh
# summarize-terminal-evidence.zsh
#
# Phase 6 Helper: Aggregate terminal evidence logs and emit a structured summary.
#
# PURPOSE
#   Reads terminal session evidence logs generated by capture-terminal-evidence.zsh
#   and produces:
#     - A concise tabular summary (stdout)
#     - Optional JSON document (stdout or file)
#     - Optional README injection (updates the terminal evidence README with a
#       standardized "Captured Artifacts" section)
#
# USAGE
#   ./tools/summarize-terminal-evidence.zsh
#   ./tools/summarize-terminal-evidence.zsh --json
#   ./tools/summarize-terminal-evidence.zsh --json --output summary.json
#   ./tools/summarize-terminal-evidence.zsh --update-readme
#   ./tools/summarize-terminal-evidence.zsh --dir custom/path
#
# OPTIONS
#   --dir <path>          Directory containing *-session-*.log files
#                         (default: docs/fix-zle/results/terminal)
#   --json                Emit JSON summary to stdout (suppresses table unless --both)
#   --output <file>       Write JSON (or full output with --both) to <file>
#   --both                Emit table + JSON (table first)
#   --update-readme       Update README.md in the evidence directory with a regenerated
#                         "Captured Artifacts" section (idempotent)
#   --strict              Exit non-zero if any required terminal fails validation
#   --term <name>         Filter to specific terminal(s) (repeatable). Names: warp wezterm ghostty kitty iterm2
#   --no-color            Disable ANSI colors
#   --help                Show help
#
# EXIT CODES
#   0  Success (or non-strict mode)
#   1  Generic error (I/O, invalid arg)
#   2  Strict mode: one or more required terminals failed
#
# REQUIRED TERMINALS (strict mode):
#   warp, wezterm, ghostty, kitty
#   iterm2 is optional
#
# ASSUMPTIONS
#   Logs contain lines such as:
#     CAPTURE_START
#     TERMINAL_TARGET=warp
#     WARP_IS_LOCAL_SHELL_SESSION=1
#     ZLE_WIDGET_COUNT=407
#     ...
#     # Notes
#     Validation: OK
#     Expected Marker: WARP_IS_LOCAL_SHELL_SESSION
#
# README INJECTION
#   We insert/update between markers:
#     <!-- CAPTURED_ARTIFACTS:BEGIN -->
#        (generated content)
#     <!-- CAPTURED_ARTIFACTS:END -->
#
# SAFETY
#   - Nounset-safe via guards
#   - Minimal external dependencies (relies on core utilities present on macOS/Linux)
#
# -----------------------------------------------------------------------------

set -uo pipefail

############################
# Color / Formatting Setup #
############################
_color=1
if [[ "${TERM:-}" == "dumb" ]]; then
  _color=0
fi

for arg in "$@"; do
  [[ "$arg" == "--no-color" ]] && _color=0
done

c_reset=$'\033[0m'
c_red=$'\033[31m'
c_green=$'\033[32m'
c_yellow=$'\033[33m'
c_blue=$'\033[34m'
c_dim=$'\033[2m'

if (( _color == 0 )); then
  for v in c_reset c_red c_green c_yellow c_blue c_dim; do
    printf -v "$v" ''
  done
fi

#################
# Helper Output #
#################
_die() {
  print -u2 "${c_red}ERROR:${c_reset} $*"
  exit 1
}

_debug() {
  [[ "${ZF_SUMMARY_DEBUG:-0}" == 1 ]] && print -u2 "[summarize] $*"
}

_usage() {
  sed -n '1,/^# -----------------------------------------------------------------------------/p' "${0}" | sed 's/^# \{0,1\}//'
  exit 0
}

####################
# Argument Parsing #
####################
_dir="docs/fix-zle/results/terminal"
_emit_json=0
_emit_table=1
_json_and_table=0
_out_file=""
_update_readme=0
_strict=0
typeset -ga _filter_terms
_filter_terms=()

while (( $# )); do
  case "$1" in
    --dir)
      shift || true
      _dir="${1:-}"
      [[ -z "${_dir}" ]] && _die "--dir requires a path"
      ;;
    --json)
      _emit_json=1
      _emit_table=0
      ;;
    --both)
      _emit_json=1
      _emit_table=1
      _json_and_table=1
      ;;
    --output)
      shift || true
      _out_file="${1:-}"
      [[ -z "${_out_file}" ]] && _die "--output requires a filename"
      ;;
    --update-readme)
      _update_readme=1
      ;;
    --strict)
      _strict=1
      ;;
    --term)
      shift || true
      [[ -z "${1:-}" ]] && _die "--term requires a value"
      _filter_terms+=("$1")
      ;;
    --no-color)
      _color=0
      ;;
    --help|-h)
      _usage
      ;;
    *)
      _die "Unknown argument: $1"
      ;;
  esac
  shift || true
done

[[ -d "${_dir}" ]] || _die "Directory not found: ${_dir}"

##############################
# Terminal / Marker Metadata #
##############################
typeset -A EXPECTED_MARKER
EXPECTED_MARKER=(
  warp    "WARP_IS_LOCAL_SHELL_SESSION"
  wezterm "WEZTERM_SHELL_INTEGRATION"
  ghostty "GHOSTTY_SHELL_INTEGRATION"
  kitty   "KITTY_SHELL_INTEGRATION"
  iterm2  ""   # optional; no marker
)

typeset -a REQUIRED_TERMINALS
REQUIRED_TERMINALS=(warp wezterm ghostty kitty)

_term_in_filter() {
  (( ${#_filter_terms[@]} == 0 )) && return 0
  local t="$1"
  for f in "${_filter_terms[@]}"; do
    [[ "$f" == "$t" ]] && return 0
  done
  return 1
}

#########################
# Log File Enumeration  #
#########################
setopt null_glob
typeset -a _logs
_logs=("${_dir}"/*-session-*.log)
unsetopt null_glob

(( ${#_logs[@]} == 0 )) && _die "No session logs found in ${_dir}"

#########################
# Parsing Functionality #
#########################
# Data arrays (parallel indices)
typeset -a T_TERMINAL T_FILE T_WIDGETS T_VALID T_EXPECTED_MARKER T_MARKER_VALUE T_CAP_BLOCK T_SYNTH
typeset -a T_ERRORS

_parse_log() {
  local f="$1"
  local base marker expected t widgets valid synth capblock
  base="$(basename "$f")"

  # Derive terminal from filename prefix
  t="${base%%-session-*}"
  # Confirm we know about the terminal
  if [[ -z "${EXPECTED_MARKER[$t]:-__UNKNOWN__}" ]]; then
    t="unknown"
  fi

  _term_in_filter "$t" || return 0

  expected="${EXPECTED_MARKER[$t]:-}"
  capblock="no"
  valid="UNKNOWN"
  widgets=""
  synth="0"
  marker=""
  local marker_val=""
  local line

  while IFS= read -r line || [[ -n "$line" ]]; do
    case "$line" in
      CAPTURE_START) capblock="yes" ;;
      TERMINAL_TARGET=*) t="${line#*=}" ;;
      ZLE_WIDGET_COUNT=*) widgets="${${line#*=}// /}" ;;
      Validation:*)
        valid="${line#Validation: }"
        ;;
      Expected\ Marker:*)
        marker="${line#Expected Marker: }"
        ;;
      *WARP_IS_LOCAL_SHELL_SESSION=*|*WEZTERM_SHELL_INTEGRATION=*|*GHOSTTY_SHELL_INTEGRATION=*|*KITTY_SHELL_INTEGRATION=*)
        # Extract marker value
        if [[ "$line" == *"="* ]]; then
          local k="${line%%=*}"
          local v="${line#*=}"
          # Only record expected marker's value if matches
          if [[ -n "$expected" && "$k" == "$expected" ]]; then
            marker_val="$v"
          fi
        fi
        ;;
      *spawn-debug*allow_synth*=1*)
        synth="1"
        ;;
      \#\ ERROR*)
        valid="FAIL"
        ;;
    esac
  done <"$f"

  # Infer failure if expected marker is non-empty but missing / zero
  if [[ -n "$expected" ]]; then
    if [[ -z "$marker_val" || "$marker_val" == "0" ]]; then
      [[ "$valid" == "OK" ]] && valid="FAIL"
    fi
  else
    # optional terminal (iterm2) treat missing marker as OK unless capture block absent
    :
  fi

  if [[ "$capblock" != "yes" && "$valid" == "OK" ]]; then
    valid="FAIL"
  fi

  # Default widgets if missing
  [[ -z "$widgets" ]] && widgets="0"

  T_TERMINAL+=("$t")
  T_FILE+=("$base")
  T_WIDGETS+=("$widgets")
  T_VALID+=("$valid")
  T_EXPECTED_MARKER+=("${expected}")
  T_MARKER_VALUE+=("${marker_val:-}")
  T_CAP_BLOCK+=("$capblock")
  T_SYNTH+=("$synth")
  T_ERRORS+=("")
}

for lf in "${_logs[@]}"; do
  _parse_log "$lf"
done

#############################
# Aggregate / Derive Status #
#############################
typeset -A _terminal_best
typeset -A _terminal_row_index

integer i=0
while (( i < ${#T_TERMINAL[@]} )); do
  local term="${T_TERMINAL[$i]}"
  # Prefer last OK capture for terminal (logs usually chronological)
  if [[ "${T_VALID[$i]}" == "OK" ]]; then
    _terminal_best["$term"]="OK"
    _terminal_row_index["$term"]="$i"
  else
    # Only set if we have nothing yet
    if [[ -z "${_terminal_best[$term]:-}" ]]; then
      _terminal_best["$term"]="${T_VALID[$i]}"
      _terminal_row_index["$term"]="$i"
    fi
  fi
  (( i++ ))
done

########################
# Strict Mode Checking #
########################
strict_fail=0
if (( _strict == 1 )); then
  for req in "${REQUIRED_TERMINALS[@]}"; do
    if [[ -z "${_terminal_best[$req]:-}" || "${_terminal_best[$req]}" != "OK" ]]; then
      strict_fail=1
    fi
  done
fi

#############
# Formatting #
#############
_print_table() {
  echo "Terminal Evidence Summary"
  echo ""
  printf "%-8s  %-8s  %-7s  %-9s  %-6s  %s\n" "TERM" "STATUS" "WIDGETS" "CAPTURE" "SYNTH" "FILE"
  printf "%-8s  %-8s  %-7s  %-9s  %-6s  %s\n" "--------" "--------" "-------" "---------" "------" "-------------------------------"
  integer j=0
  while (( j < ${#T_TERMINAL[@]} )); do
    local term="${T_TERMINAL[$j]}"
    local status="${T_VALID[$j]}"
    local wid="${T_WIDGETS[$j]}"
    local cap="${T_CAP_BLOCK[$j]}"
    local synth="${T_SYNTH[$j]}"
    local file="${T_FILE[$j]}"

    local color=""
    case "$status" in
      OK) color=$c_green ;;
      FAIL) color=$c_red ;;
      *) color=$c_yellow ;;
    esac

    printf "%s%-8s%s  %-8s  %-7s  %-9s  %-6s  %s\n" \
      "$color" "$term" "$c_reset" "$status" "$wid" "$cap" "$synth" "$file"
    (( j++ ))
  done
  echo ""
  echo "Legend: WIDGETS = reported ZLE widget count, CAPTURE=yes/no CAPTURE_START block, SYNTH=1 if synthetic marker allowed"
}

################
# JSON Builder #
################
_json_escape() {
  # very minimal escape (quotes + backslashes)
  local s="${1//\\/\\\\}"
  s="${s//\"/\\\"}"
  print -r -- "$s"
}

_emit_json_summary() {
  echo "{"
  echo '  "terminals": {'
  integer j=0
  local first_t=1
  while (( j < ${#T_TERMINAL[@]} )); do
    local term="${T_TERMINAL[$j]}"
    local status="${T_VALID[$j]}"
    local widgets="${T_WIDGETS[$j]}"
    local cap="${T_CAP_BLOCK[$j]}"
    local synth="${T_SYNTH[$j]}"
    local f="${T_FILE[$j]}"
    local exp="${T_EXPECTED_MARKER[$j]}"
    local mv="${T_MARKER_VALUE[$j]}"
    local comma=","
    (( j == ${#T_TERMINAL[@]} - 1 )) && comma=""
    printf '    "%s": { "file": "%s", "status": "%s", "widgets": %s, "capture_block": "%s", "synthetic": %s, "expected_marker": "%s", "marker_value": "%s" }%s\n' \
      "$(_json_escape "$term")" \
      "$(_json_escape "$f")" \
      "$(_json_escape "$status")" \
      "$widgets" \
      "$cap" \
      "$synth" \
      "$(_json_escape "$exp")" \
      "$(_json_escape "$mv")" \
      "$comma"
    (( j++ ))
  done
  echo "  },"
  echo '  "required_terminals": ["warp","wezterm","ghostty","kitty"],'
  local overall="OK"
  (( strict_fail == 1 )) && overall="FAIL"
  printf '  "strict_overall": "%s"\n' "$overall"
  echo "}"
}

#########################
# README Update Section #
#########################
_update_readme_section() {
  local readme="${_dir}/README.md"
  [[ -f "${readme}" ]] || _die "README not found at ${readme}"

  local begin="<!-- CAPTURED_ARTIFACTS:BEGIN -->"
  local end="<!-- CAPTURED_ARTIFACTS:END -->"

  # Build new content block
  local tmpblock
  tmpblock="$(mktemp -t term-summary.XXXXXX)"
  {
    echo "${begin}"
    echo "### Captured Artifacts (Generated)"
    echo ""
    echo "| Terminal | Status | Widgets | Capture | Synth | File | Marker | Value |"
    echo "|----------|--------|---------|---------|-------|------|--------|-------|"
    integer k=0
    while (( k < ${#T_TERMINAL[@]} )); do
      printf "| %s | %s | %s | %s | %s | %s | %s | %s |\n" \
        "${T_TERMINAL[$k]}" "${T_VALID[$k]}" "${T_WIDGETS[$k]}" "${T_CAP_BLOCK[$k]}" \
        "${T_SYNTH[$k]}" "${T_FILE[$k]}" "${T_EXPECTED_MARKER[$k]:-(none)}" "${T_MARKER_VALUE[$k]:-(empty)}"
      (( k++ ))
    done
    echo ""
    echo "_Updated: $(date -u +%Y-%m-%dT%H:%M:%SZ)_"
    echo "${end}"
  } > "${tmpblock}"

  # If markers exist, replace; else append
  if grep -q "${begin}" "${readme}" 2>/dev/null; then
    awk -v b="${begin}" -v e="${end}" -v file="${tmpblock}" '
      BEGIN {
        inblock=0
        while ((getline line < file) > 0) {
          newblock = newblock line "\n"
        }
        close(file)
      }
      $0 ~ b { print newblock; inblock=1; next }
      $0 ~ e { inblock=0; next }
      !inblock { print $0 }
    ' "${readme}" > "${readme}.tmp" && mv "${readme}.tmp" "${readme}"
  else
    {
      echo ""
      cat "${tmpblock}"
    } >> "${readme}"
  fi
  rm -f "${tmpblock}"
  echo "Updated README artifacts section."
}

########
# Main #
########
{
  (( _emit_table == 1 )) && _print_table
  if (( _emit_json == 1 )); then
    local json_out
    json_out="$(_emit_json_summary)"
    if [[ -n "${_out_file}" ]]; then
      print -r -- "$json_out" > "${_out_file}"
      echo "Wrote JSON summary to ${_out_file}"
    else
      print -r -- "$json_out"
    fi
  fi
  if (( _update_readme == 1 )); then
    _update_readme_section
  fi
} || _die "Unexpected failure generating summary"

if (( strict_fail == 1 )); then
  echo "${c_red}Strict mode: one or more required terminals FAILED.${c_reset}"
  exit 2
fi

exit 0
