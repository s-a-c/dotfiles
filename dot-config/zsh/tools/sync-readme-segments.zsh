#!/usr/bin/env zsh
# sync-readme-segments.zsh
# Compliant with /Users/s-a-c/dotfiles/dot-config/ai/guidelines.md v900f08def0e6f7959ffd283aebb73b625b3473f5e49c57e861c6461b50a62ef2
#
# PURPOSE:
#   Synchronize the canonical segment / telemetry classifier documentation
#   (REFERENCE.md §5.3 + its subsections 5.3.1–5.3.4) into README.md between
#   managed markers:
#
#       <!-- BEGIN:SEGMENTS_SYNC -->
#       ... (auto generated content) ...
#       <!-- END:SEGMENTS_SYNC -->
#
#   This prevents documentation drift between REFERENCE.md and README.md.
#
# FEATURES:
#   - Idempotent (only rewrites block if content changes)
#   - DRY_RUN mode: preview without modifying README
#   - --check mode: exits non‑zero if README is out of sync (CI integration)
#   - --diff  mode: shows unified diff (requires `diff` utility)
#   - Safe atomic write (temp file + mv)
#
# USAGE:
#   tools/sync-readme-segments.zsh
#   DRY_RUN=1 tools/sync-readme-segments.zsh
#   tools/sync-readme-segments.zsh --check      # For CI gating (no change, exit 3 on mismatch)
#   tools/sync-readme-segments.zsh --diff       # Show diff (implies DRY_RUN)
#
# EXIT CODES:
#   0  Success (in sync or updated)
#   1  Usage / argument error
#   2  Failed to extract section from REFERENCE.md
#   3  --check / --diff detected mismatch (README out of sync)
#   4  Filesystem / write failure
#
# ENVIRONMENT:
#   DRY_RUN=1      Do not modify README, just report intended change
#   VERBOSE=1      Emit additional diagnostic logs
#
# DEPENDENCIES:
#   - awk (standard)
#   - diff (optional: for --diff)
#
# IMPLEMENTATION NOTES:
#   Extraction stops at the first new top-level heading beginning with '## ' after
#   the §5.3 block. Sub-headings (#### etc.) within §5.3 are preserved.
#
# FUTURE ENHANCEMENTS:
#   - Add test harness to verify round-trip (README -> REFERENCE) integrity
#   - Support additional mirrored sections (parametrized list)
#

set -euo pipefail

SCRIPT_DIR="${0:A:h}"
REPO_ROOT="${SCRIPT_DIR:A}/.."
# Normalize to absolute path (fixes awk path open failure when run with -f)
REPO_ROOT="$(cd "$REPO_ROOT" && pwd)"
DOC_ROOT="${REPO_ROOT}/docs/redesignv2"

REFERENCE_FILE="${DOC_ROOT}/REFERENCE.md"
README_FILE="${DOC_ROOT}/README.md"

HEADER_MARK="<!-- BEGIN:SEGMENTS_SYNC -->"
FOOTER_MARK="<!-- END:SEGMENTS_SYNC -->"

DRY_RUN="${DRY_RUN:-0}"
VERBOSE="${VERBOSE:-0}"
MODE_CHECK=0
MODE_DIFF=0

print_err() { print -r -- "[sync][ERROR] $*" >&2; }
print_info() { (( VERBOSE )) && print -r -- "[sync][INFO]  $*" >&2 || true; }
print_warn() { print -r -- "[sync][WARN]  $*" >&2; }

usage() {
  cat <<EOF
Usage: ${0:t} [--check] [--diff] [--help]

Synchronize REFERENCE.md §5.3 canonical performance segments into README.md.

Options:
  --check   Exit 3 if README.md is out of sync (no modifications)
  --diff    Show unified diff of proposed change (implies DRY_RUN; exit 3 if mismatch)
  --help    Show this help

Environment:
  DRY_RUN=1   Preview changes (no write)
  VERBOSE=1   Verbose logging

Exit Codes:
  0 success / already in sync / updated
  1 usage error
  2 extraction failure
  3 out of sync (check/diff mode) or diff shown
  4 write failure
EOF
}

# ---------------- Argument Parsing ----------------
while (( $# > 0 )); do
  case "$1" in
    --check) MODE_CHECK=1 ;;
    --diff)  MODE_DIFF=1; DRY_RUN=1 ;;
    --help|-h) usage; exit 0 ;;
    *) print_err "Unknown argument: $1"; usage; exit 1 ;;
  esac
  shift
done

# ---------------- Pre-flight Checks ----------------
[[ -r "$REFERENCE_FILE" ]] || { print_err "Cannot read REFERENCE file: $REFERENCE_FILE"; exit 2; }
[[ -r "$README_FILE" ]]    || { print_err "Cannot read README file: $README_FILE"; exit 2; }

# ---------------- Extract Section 5.3 ----------------
# Strategy:
#   Start copying when line matches /^### 5\.3 /
#   Stop when a new top-level heading (## ) appears (excluding lines inside the section)
#
SECTION_CONTENT="$(
  awk '
    BEGIN {capture=0}
    /^### 5\.3[[:space:]]/ {capture=1}
    capture && /^## [0-9]+\./ && $0 !~ /^### 5\.3[[:space:]]/ {capture=0}
    capture
  ' "$REFERENCE_FILE"
)"

if [[ -z "$SECTION_CONTENT" ]]; then
  print_err "Failed to extract §5.3 canonical performance segments from REFERENCE.md"
  exit 2
fi

print_info "Extracted §5.3 block (lines: $(echo "$SECTION_CONTENT" | wc -l | tr -d ' '))."

# ---------------- Build Managed Block ----------------
read -r -d '' MANAGED_BLOCK <<EOF || true
$HEADER_MARK
<!-- NOTE: AUTO-GENERATED by tools/sync-readme-segments.zsh. Do NOT edit inside markers. -->
$SECTION_CONTENT
$FOOTER_MARK
EOF

# Ensure trailing newline
MANAGED_BLOCK="${MANAGED_BLOCK%%$'\n'}"$'\n'
# Prepare temporary file for block (avoids complex escaping in inline substitution tools)
block_file="$(mktemp -t segments-block.XXXXXX)"
printf "%s" "$MANAGED_BLOCK" > "$block_file"
trap 'rm -f "$block_file"' EXIT INT TERM

# ---------------- Detect Existing Block ----------------
README_ORIG_CONTENT="$(<"$README_FILE")"

if ! grep -q "$HEADER_MARK" "$README_FILE"; then
  print_info "Markers not found in README. Will append a new synchronized section."
  NEW_README_CONTENT="${README_ORIG_CONTENT}
## Canonical Performance Segments (Synchronized)

${MANAGED_BLOCK}"
else
  # Replace existing block (non-greedy up to FOOTER_MARK)
  # Use perl for multiline safety.
  # Replace existing block using awk (no perl dependency; safe with table pipes)
  NEW_README_CONTENT=$(
    awk -v hdr="$HEADER_MARK" -v ftr="$FOOTER_MARK" -v bf="$block_file" '
      function emit_block() {
        while ( (getline line < bf) > 0 ) { print line }
        close(bf)
      }
      {
        if ($0 == hdr) {
          emit_block()
          skip=1
          next
        }
        if ($0 == ftr && skip) {
          # Footer already included in managed block
          skip=0
          next
        }
        if (!skip) print
      }
    ' "$README_FILE"
  )
fi

# ---------------- Compare ----------------
if [[ "$NEW_README_CONTENT" == "$README_ORIG_CONTENT" ]]; then
  print_info "README already in sync; no changes required."
  if (( MODE_CHECK || MODE_DIFF )); then
    # In check/diff mode and already in sync: exit success
    exit 0
  fi
  exit 0
fi

# ---------------- Show Diff (if requested) ----------------
if (( MODE_DIFF )); then
  if command -v diff >/dev/null 2>&1; then
    tmp_orig="$(mktemp -t readme-orig.XXXXXX)"
    tmp_new="$(mktemp -t readme-new.XXXXXX)"
    printf "%s" "$README_ORIG_CONTENT" > "$tmp_orig"
    printf "%s" "$NEW_README_CONTENT" > "$tmp_new"
    print_warn "README is out of sync. Showing diff:"
    diff -u "$tmp_orig" "$tmp_new" || true
    rm -f "$tmp_orig" "$tmp_new"
  else
    print_warn "diff utility not found; cannot show unified diff."
  fi
  # In diff mode always signal mismatch if changed
  exit 3
fi

# ---------------- Check Mode (no write) ----------------
if (( MODE_CHECK )); then
  print_warn "README out of sync with REFERENCE §5.3 (run script without --check to update)."
  exit 3
fi

# ---------------- DRY RUN (preview) ----------------
if (( DRY_RUN )); then
  print_warn "DRY_RUN=1 → README would be updated. Preview of managed block:"
  print -r -- "----- BEGIN MANAGED BLOCK -----"
  print -r -- "$MANAGED_BLOCK"
  print -r -- "----- END MANAGED BLOCK -----"
  exit 0
fi

# ---------------- Write Updated README ----------------
tmp_write="$(mktemp -t readme-sync-write.XXXXXX)" || { print_err "Could not create temp file"; exit 4; }
printf "%s" "$NEW_README_CONTENT" > "$tmp_write" || { print_err "Failed writing temp file"; rm -f "$tmp_write"; exit 4; }

# Atomic replace
mv "$tmp_write" "$README_FILE" || { print_err "Failed to replace README (mv failed)"; rm -f "$tmp_write"; exit 4; }

print_info "README updated with synchronized segment block."
print -r -- "[sync] SUCCESS: README synchronized."
exit 0
